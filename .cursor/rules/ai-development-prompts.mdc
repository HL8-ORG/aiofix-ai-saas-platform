---
description: AI开发提示词系统
globs:
alwaysApply: true
---
# AI开发提示词系统

## 概述

本文档提供了一套完整的AI开发提示词，用于引导AI参与SAAS平台的开发工作。这些提示词基于项目的业务需求文档和技术设计文档，确保AI能够理解项目架构、业务逻辑和技术实现要求。

## 核心提示词

### 1. 项目上下文提示词

```
你是一个全栈工程师，精通TypeScript语言，有丰富的Node.js开发经验。

项目背景：
- 这是一个现代化的SAAS平台项目，支持多租户架构
- 采用DDD（领域驱动设计）+ Clean Architecture + CQRS + 事件溯源架构
- 技术栈：NestJS + TypeScript + Fastify + MikroORM + PostgreSQL + MongoDB + Redis
- 支持从单体应用到微服务架构的渐进式演进

开发原则：
- 使用中文回答问题和编写注释
- 编写注释应当按照TSDoc规范，并加入代码设计原理或机制，以及业务规则或业务逻辑
- 修改代码时应当同时修改相应的注释，确保代码与注释一致
- 创建文件时优先采用分段创建文件的策略，避免工具调用超时
- 使用pnpm作为包管理器
- 完成代码编写后应当进行代码linter检查，及时修复报错
- 检查和修复linter错误时你可以调用mcp-server lint-files
- 开发任务完成后应当进行编译检查，及时处理报错

项目文档：
- 业务需求文档：../../docs/business-requirements.md
- 技术设计文档：../../docs/technical-design/README.md
- 请仔细阅读相关文档，理解业务需求和技术架构
```

### 2. 架构理解提示词

```
请基于以下架构信息进行开发：

架构模式：
- 分层架构：Interface Layer → Application Layer → Domain Layer → Infrastructure Layer
- CQRS模式：命令和查询分离，命令处理写操作，查询处理读操作
- 事件溯源：所有状态变更都通过事件记录，支持时间旅行和审计
- 多租户架构：支持平台级、租户级、组织级、部门级、用户级的数据隔离

核心概念：
- 聚合根：User、Tenant、Organization、Department、Role等
- 领域事件：UserCreatedEvent、TenantAssignedEvent等
- 命令：CreateUserCommand、AssignUserToTenantCommand等
- 查询：GetUserQuery、GetUsersQuery等
- 仓储：IUserRepository、ITenantRepository等

数据隔离：
- 五层数据隔离：Platform → Tenant → Organization → Department → User
- 数据分类：可共享数据、受保护数据
- 权限控制：基于角色的访问控制（RBAC）
```

### 3. 业务逻辑提示词

```
请基于以下业务规则进行开发：

用户管理：
- 所有用户首先都是平台用户，然后可能成为租户用户
- 用户不能同时被分配到不同租户
- 租户用户可以被分配到同一租户的不同组织和部门（兼职）
- 用户离开租户后仍然是平台用户

权限管理：
- 8种基础角色：平台管理员、租户管理员、组织管理员、部门管理员、个人用户、租户用户、系统管理员、服务账户
- 权限继承：下级权限自动继承上级权限
- 最小权限原则：用户只能获得完成工作所需的最小权限
- 实时权限验证：每次数据访问都需要实时权限验证

数据访问控制：
- 平台级数据访问：平台管理员可以访问所有平台数据
- 租户级数据访问：租户管理员可以访问租户内所有数据
- 组织级数据访问：组织管理员可以访问组织内数据
- 部门级数据访问：部门管理员可以访问部门内数据
- 用户级数据访问：用户只能访问自己的数据
```

### 4. 技术实现提示词

```
请按照以下技术规范进行开发：

代码组织：
- 使用DDD的限界上下文组织代码
- 每个聚合根都有对应的命令、查询、事件处理器
- 使用依赖注入和接口抽象
- 遵循SOLID原则

数据库设计：
- 使用MikroORM作为统一ORM
- PostgreSQL用于结构化数据（用户、租户、组织等）
- MongoDB用于非结构化数据（日志、配置等）
- 事件存储支持PostgreSQL和MongoDB

错误处理：
- 使用自定义异常类
- 全局异常过滤器
- 详细的错误日志记录
- 优雅的错误恢复机制

性能优化：
- 使用Redis缓存
- 事件溯源快照机制
- 数据库查询优化
- 异步事件处理
```

## 特定场景提示词

### 5. 领域模型开发提示词

```
请为[具体聚合根名称]开发领域模型：

要求：
1. 创建聚合根类，包含业务逻辑和不变性约束
2. 定义值对象，封装业务概念
3. 创建领域事件，记录状态变更
4. 实现业务规则验证
5. 添加领域服务（如需要）

示例结构：
```typescript
export class [AggregateRoot] {
  // 聚合根属性
  // 业务方法
  // 事件发布
  // 不变性验证
}

export class [AggregateRoot]CreatedEvent implements IDomainEvent {
  // 事件属性
  // 事件方法
}
```

请确保：
- 聚合根保持业务不变性
- 所有状态变更都通过事件记录
- 业务规则在领域层实现
- 代码有详细的中文注释
```

### 6. 应用层开发提示词

```
请为[具体功能模块]开发应用层代码：

要求：
1. 创建命令和查询定义
2. 实现命令处理器和查询处理器
3. 创建应用服务协调业务用例
4. 实现事件处理器更新读模型
5. 添加事务管理

示例结构：
```typescript
// 命令定义
export class [Action]Command {
  constructor(/* 参数 */) {}
}

// 命令处理器
@CommandHandler([Action]Command)
export class [Action]Handler {
  async execute(command: [Action]Command): Promise<void> {
    // 业务逻辑实现
  }
}

// 应用服务
@Injectable()
export class [Module]ApplicationService {
  // 协调业务用例
}
```

请确保：
- 命令处理器实现业务用例
- 查询处理器优化读性能
- 事件处理器保持读模型同步
- 事务边界正确设置
```

### 7. 基础设施层开发提示词

```
请为[具体数据存储]开发基础设施层代码：

要求：
1. 创建实体/文档定义
2. 实现仓储接口
3. 创建数据库迁移
4. 实现事件存储
5. 添加缓存策略

示例结构：
```typescript
// 实体定义
@Entity({ tableName: '[table_name]' })
export class [Entity]Entity {
  // 实体属性
  // 数据库映射
}

// 仓储实现
@Injectable()
export class [Entity]Repository implements I[Entity]Repository {
  // 仓储方法实现
  // 数据隔离逻辑
}

// 事件存储
@Injectable()
export class EventStoreService implements IEventStore {
  // 事件存储实现
}
```

请确保：
- 实体映射正确
- 数据隔离策略实现
- 查询性能优化
- 缓存策略合理
```

### 8. 接口层开发提示词

```
请为[具体API端点]开发接口层代码：

要求：
1. 创建控制器
2. 实现请求验证
3. 添加权限检查
4. 实现响应格式化
5. 添加API文档

示例结构：
```typescript
@Controller('[route]')
@UseGuards(AuthGuard, PermissionGuard)
export class [Module]Controller {
  @Post()
  @RequirePermissions('[permission]')
  async [action](@Body() command: [Action]Command): Promise<[Response]Dto> {
    // 控制器逻辑
  }
}
```

请确保：
- 输入验证完整
- 权限检查正确
- 错误处理优雅
- API文档清晰
```

### 9. 测试开发提示词

```
请为[具体模块]开发测试代码：

要求：
1. 单元测试：测试业务逻辑
2. 集成测试：测试组件协作
3. 端到端测试：测试完整流程
4. 性能测试：测试系统性能
5. 安全测试：测试安全漏洞

测试类型：
- 单元测试：使用Jest，测试领域逻辑
- 集成测试：使用TestContainers，测试数据库交互
- 端到端测试：使用Supertest，测试API端点
- 性能测试：使用Artillery，测试系统负载

请确保：
- 测试覆盖率达标
- 测试用例完整
- 测试数据隔离
- 测试性能良好
```

### 10. 部署运维提示词

```
请为[具体环境]配置部署和运维：

要求：
1. Docker容器化配置
2. Kubernetes部署配置
3. 数据库配置和迁移
4. 监控和日志配置
5. 安全配置

配置文件：
- Dockerfile：应用容器化
- docker-compose.yml：本地开发环境
- k8s/：Kubernetes部署配置
- monitoring/：监控配置
- security/：安全配置

请确保：
- 容器配置优化
- 部署配置完整
- 监控覆盖全面
- 安全策略严格
```

## 使用指南

### 11. 提示词使用流程

```
开发流程：
1. 首先使用"项目上下文提示词"建立基础理解
2. 根据开发任务选择相应的特定场景提示词
3. 结合业务需求文档和技术设计文档
4. 按照提示词要求进行开发
5. 完成后进行代码检查和测试

质量保证：
- 代码必须通过linter检查
- 必须包含完整的中文注释
- 必须遵循项目架构规范
- 必须实现相应的测试用例
- 必须考虑数据隔离和权限控制
```

### 12. 常见问题解决提示词

```
遇到以下问题时，请参考相应解决方案：

架构问题：
- 如何设计聚合根？参考领域模型设计文档
- 如何实现数据隔离？参考多租户数据隔离文档
- 如何处理事件？参考事件溯源设计文档

业务问题：
- 用户管理逻辑？参考业务需求文档第4.5节
- 权限控制规则？参考业务需求文档第4.7节
- 数据访问控制？参考业务需求文档第5.2节

技术问题：
- 数据库设计？参考基础设施实现文档
- 应用层实现？参考应用层实现文档
- 部署配置？参考部署与运维文档

性能问题：
- 查询优化？使用缓存和索引
- 事件处理？使用异步处理和批量操作
- 系统监控？使用Prometheus和Grafana
```

## 提示词模板

### 13. 通用开发模板

```
基于以下信息开发[具体功能]：

业务需求：
- 参考：../../docs/business-requirements.md 第[X]节
- 核心功能：[具体功能描述]
- 业务规则：[具体业务规则]

技术实现：
- 参考：../../docs/technical-design/[相关文档]
- 架构模式：[具体架构模式]
- 技术栈：[具体技术栈]

开发要求：
1. 遵循项目架构规范
2. 实现完整的业务逻辑
3. 添加详细的中文注释
4. 包含相应的测试用例
5. 考虑数据隔离和权限控制

请提供：
- 完整的代码实现
- 详细的实现说明
- 测试用例建议
- 部署配置建议
```

### 14. 代码审查提示词

```
请审查以下代码：

审查重点：
1. 架构合规性：是否符合DDD和Clean Architecture
2. 业务逻辑：是否正确实现业务需求
3. 数据隔离：是否正确实现多租户隔离
4. 权限控制：是否正确实现权限验证
5. 性能优化：是否有性能问题
6. 安全性：是否有安全漏洞
7. 可维护性：代码是否清晰易懂
8. 测试覆盖：是否有足够的测试

请提供：
- 问题识别和修复建议
- 代码改进建议
- 最佳实践建议
- 性能优化建议
```

## 总结

这套提示词系统涵盖了SAAS平台开发的各个方面，从项目理解到具体实现，从架构设计到部署运维。通过使用这些提示词，AI能够：

1. **理解项目背景**：掌握业务需求和技术架构
2. **遵循开发规范**：按照项目标准进行开发
3. **实现业务逻辑**：正确实现复杂的多租户业务
4. **保证代码质量**：确保代码的可维护性和可扩展性
5. **考虑系统性能**：实现高性能和高可用的系统

使用这些提示词时，请根据具体的开发任务选择合适的提示词，并结合项目的业务需求文档和技术设计文档，确保开发工作符合项目要求。

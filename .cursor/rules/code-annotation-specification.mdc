---
description: 代码注释规则
globs:
alwaysApply: true
---

# SAAS平台代码注释规范（Code Annotation Specification）

**遵循代码即文档的思想，应当保证代码与注释的一致性和规范性。**

## 项目背景

- **项目名称**: Aiofix AI SAAS平台
- **架构模式**: Clean Architecture + DDD + CQRS + Event Sourcing + Event-Driven Architecture
- **多租户支持**: 支持数据库级、Schema级、表级三种隔离策略
- **技术栈**: NestJS + TypeScript + Fastify + MikroORM + PostgreSQL + MongoDB + Redis + BullMQ + nestjs-cls

## 架构设计参考

本项目的代码注释规范基于以下技术设计文档：

- **[01-架构概述](../docs/technical-design-documents/01-architecture-overview.md)** - 项目整体架构设计
- **[02-Clean Architecture分层设计](../docs/technical-design-documents/02-clean-architecture-layers.md)** - 四层架构详细设计
- **[03-Entities层设计](../docs/technical-design-documents/03-entities-layer.md)** - 领域实体、聚合根、值对象设计
- **[04-Use Cases层设计](../docs/technical-design-documents/04-use-cases-layer.md)** - 应用用例、命令查询设计
- **[05-Interface Adapters层设计](../docs/technical-design-documents/05-interface-adapters-layer.md)** - 控制器、DTO、仓储实现设计
- **[06-Frameworks & Drivers层设计](../docs/technical-design-documents/06-frameworks-drivers-layer.md)** - 数据库、消息队列、Web框架设计
- **[13-事件溯源设计](../docs/technical-design-documents/13-event-sourcing-design.md)** - 事件溯源模式设计
- **[14-适配器模式设计](../docs/technical-design-documents/14-adapter-pattern-design.md)** - 数据库适配器、多租户支持设计

## **代码注释规则**

- 本项目代码应当按照 TSDoc 规范添加注释。
- 使用中文进行注释，确保团队理解的一致性。
- 注释应当清晰、准确、完整，避免冗余和过时的信息。
- 所有公共 API、类、方法、接口、枚举等都必须添加完整的 TSDoc 注释。
  示例：**TSDoc 注释结构**
  - 基本结构

```typescript
/**
 * @description 功能描述
 * @param {Type} paramName 参数描述
 * @returns {Type} 返回值描述
 * @throws {ErrorType} 异常描述
 * @example 使用示例
 */
```

- 详细结构

````typescript
/**
 * @function functionName
 * @description
 * 详细的功能描述，包含：
 * 1. 主要功能说明
 * 2. 使用场景
 * 3. 注意事项
 *
 * 原理与机制：
 * 1. 实现原理说明
 * 2. 技术选型理由
 * 3. 性能考虑
 *
 * 功能与职责：
 * 1. 核心职责
 * 2. 边界条件
 * 3. 依赖关系
 *
 * @param {Type} paramName 参数详细描述
 * @param {Type} [optionalParam] 可选参数描述
 * @returns {Type} 返回值详细描述
 * @throws {ErrorType} 可能抛出的异常及条件
 * @example
 * ```typescript
 * const result = functionName(param1, param2);
 * console.log(result);
 * ```
 * @since 1.0.0
 * @deprecated 如果已废弃，说明替代方案
 */
````

````ts
import { NestFactory } from '@nestjs/core';
import {
  FastifyAdapter,
  NestFastifyApplication,
} from '@nestjs/platform-fastify';
import { AppModule } from './app.module';

/**
 * @function bootstrap
 * @description
 * 启动NestJS应用的主函数。该函数负责创建基于Fastify平台的应用实例，
 * 并监听指定端口启动高性能HTTP服务。
 *
 * 功能与职责：
 * 1. 启动应用服务器
 * 2. 配置全局中间件和管道
 * 3. 初始化数据库连接
 * 4. 启动事件监听器
 *
 * @returns {Promise<void>} 返回一个Promise，表示应用启动过程
 * @throws {Error} 当端口被占用或配置错误时抛出异常
 * @example
 * ```typescript
 * // 启动应用
 * bootstrap().catch(error => {
 *   console.error('Failed to start application:', error);
 *   process.exit(1);
 * });
 * ```
 * @since 1.0.0
 */
async function bootstrap() {
  // 创建基于Fastify的Nest应用实例
  const app = await NestFactory.create<NestFastifyApplication>(
    AppModule,
    new FastifyAdapter(),
  );

  // 启动HTTP服务，监听指定端口
  await app.listen(process.env.PORT ?? 3000, '0.0.0.0');
}

// 启动应用
bootstrap();
````

## 特别说明

### 功能描述应体现架构设计的要求

#### Clean Architecture四层架构要求

- **Entities层（实体层）**：
  - 聚合根应当描述业务方法、事件发布、不变性约束和事件溯源支持
  - 领域实体应当描述身份标识、状态管理和生命周期
  - 值对象应当描述不变性约束、相等性判断和业务概念封装
  - 领域事件应当描述事件含义、触发条件、影响范围和事件溯源信息
  - 领域服务应当描述跨聚合的业务逻辑和无状态操作
  - 仓储接口应当描述数据访问抽象和业务规则

- **Use Cases层（用例层）**：
  - 应用用例应当描述业务流程、协调逻辑、事务边界和事件发布
  - 命令处理器应当描述命令验证、业务规则检查、聚合操作和事件发布
  - 查询处理器应当描述查询优化、数据隔离、权限过滤和缓存策略
  - 应用服务应当描述用例编排、依赖协调和异常处理

- **Interface Adapters层（接口适配器层）**：
  - 控制器应当描述HTTP请求处理、数据验证、权限控制和响应格式化
  - DTO应当描述数据传输结构、验证规则和API文档支持
  - 仓储实现应当描述数据持久化、查询优化和多租户隔离
  - 外部服务适配器应当描述服务集成、错误处理和重试机制

- **Frameworks & Drivers层（框架驱动层）**：
  - 数据库适配器应当描述连接管理、查询执行、事务支持和多租户隔离
  - 消息队列服务应当描述消息发布、消费、重试机制和可靠性保证
  - 事件存储应当描述事件持久化、版本控制、快照机制和事件重放
  - 事件投射器应当描述读模型更新、事件处理和投影状态管理

#### 事件驱动架构要求

- **事件溯源支持**：
  - 聚合根必须继承EventSourcedAggregateRoot并实现事件应用方法
  - 事件必须包含完整的业务信息和元数据
  - 事件存储必须支持版本控制和并发控制
  - 事件投射器必须支持幂等性和错误恢复

- **异步事件处理**：
  - 事件处理器应当描述事件处理流程、重试机制和错误处理
  - 消息队列服务应当描述消息发布、消费和可靠性保证
  - 事件总线服务应当描述事件存储、消息队列集成和异步处理

#### 多租户架构要求

- **数据隔离策略**：
  - 所有涉及数据隔离的代码必须详细说明其隔离策略（数据库级、Schema级、表级）
  - 租户感知组件必须描述租户上下文管理和隔离条件应用
  - 权限控制组件必须描述访问控制机制和数据过滤策略

- **配置驱动支持**：
  - 适配器工厂必须描述隔离策略的动态切换和配置管理
  - 隔离配置服务必须描述策略配置、租户管理和配置验证

## **架构组件注释示例**

### 1. 领域实体 (Domain Entity) 示例

````typescript
/**
 * @class UserEntity
 * @description
 * 用户领域实体，负责维护用户的身份标识、状态管理和生命周期。
 *
 * 身份标识与状态管理：
 * 1. 通过唯一ID标识用户身份
 * 2. 管理用户的基本状态（激活、禁用、删除）
 * 3. 维护用户的生命周期状态变更
 *
 * 业务规则与约束：
 * 1. 用户ID一旦创建不可变更
 * 2. 用户状态变更必须遵循预定义的状态机
 * 3. 删除用户时采用软删除策略
 *
 * @property {string} id 用户唯一标识符，不可变更
 * @property {string} email 用户邮箱地址，用于身份验证
 * @property {UserStatus} status 用户当前状态
 * @property {Date} createdAt 用户创建时间
 * @property {Date} updatedAt 用户最后更新时间
 * @property {Date} deletedAt 用户删除时间（软删除）
 *
 * @example
 * ```typescript
 * const user = new UserEntity('user-123', 'user@example.com');
 * user.activate(); // 激活用户
 * user.deactivate(); // 禁用用户
 * ```
 * @since 1.0.0
 */
export class UserEntity {
  constructor(
    public readonly id: string,
    public readonly email: string,
    private status: UserStatus = UserStatus.PENDING,
  ) {}

  /**
   * @method activate
   * @description 激活用户，将状态从PENDING或DISABLED变更为ACTIVE
   * @returns {void}
   * @throws {InvalidStateTransitionError} 当用户状态不允许激活时抛出
   */
  activate(): void {
    // 实现状态变更逻辑
  }
}
````

### 2. 聚合根 (Aggregate Root) 示例

````typescript
/**
 * @class UserAggregate
 * @description
 * 用户聚合根，负责管理用户相关的业务方法、事件发布、不变性约束和事件溯源支持。
 *
 * 业务方法与事件发布：
 * 1. 提供用户创建、更新、删除等业务方法
 * 2. 在状态变更时发布相应的领域事件
 * 3. 确保业务操作的事务一致性
 * 4. 支持事件溯源的状态重建
 *
 * 不变性约束：
 * 1. 用户邮箱在租户内必须唯一
 * 2. 用户不能同时属于多个租户
 * 3. 用户删除前必须清理所有关联数据
 * 4. 事件版本必须连续递增
 *
 * 事件溯源支持：
 * 1. 继承EventSourcedAggregateRoot基类
 * 2. 实现事件应用方法进行状态重建
 * 3. 支持从事件历史重建聚合状态
 * 4. 提供快照机制优化性能
 *
 * @property {UserEntity} user 用户实体
 * @property {TenantId} tenantId 所属租户ID
 * @property {DomainEvent[]} uncommittedEvents 未提交的领域事件
 * @property {number} version 聚合版本号，用于乐观并发控制
 *
 * @example
 * ```typescript
 * // 创建用户聚合根
 * const userAggregate = UserAggregate.create(
 *   userId, email, password, profile, preferences
 * );
 * // 自动发布 UserCreatedEvent
 *
 * // 从事件历史重建聚合根
 * const events = await eventStore.getEvents(userId);
 * const rebuiltAggregate = UserAggregate.fromEvents(events);
 * ```
 * @since 1.0.0
 */
export class UserAggregate extends EventSourcedAggregateRoot {
  private constructor(
    private user: UserEntity,
    private tenantId: TenantId,
  ) {
    super();
  }

  /**
   * @method create
   * @description 创建新用户聚合根，发布用户创建事件
   * @param {UserId} id 用户ID
   * @param {Email} email 用户邮箱
   * @param {Password} password 用户密码
   * @param {UserProfile} profile 用户资料
   * @param {UserPreferences} preferences 用户偏好
   * @returns {UserAggregate} 创建的用户聚合根
   * @throws {DuplicateEmailError} 当邮箱已存在时抛出
   * @throws {InvalidTenantError} 当租户不存在时抛出
   *
   * 创建流程：
   * 1. 验证业务规则和约束
   * 2. 创建用户实体
   * 3. 发布用户创建事件
   * 4. 返回聚合根实例
   */
  static create(
    id: UserId,
    email: Email,
    password: Password,
    profile: UserProfile,
    preferences: UserPreferences,
  ): UserAggregate {
    const userEntity = new UserEntity(
      id,
      email,
      password,
      profile,
      preferences,
    );
    const aggregate = new UserAggregate(userEntity, profile.tenantId);

    // 发布领域事件 - 事件溯源的核心
    aggregate.addDomainEvent(
      new UserCreatedEvent(id, email, profile.tenantId, profile, new Date()),
    );

    return aggregate;
  }

  /**
   * @method fromEvents
   * @description 从事件历史重建用户聚合根
   * @param {IDomainEvent[]} events 事件历史列表
   * @returns {UserAggregate} 重建的聚合根
   * @throws {AggregateCorruptionError} 当事件数据损坏时抛出
   *
   * 重建流程：
   * 1. 创建空的聚合根实例
   * 2. 按顺序应用所有事件
   * 3. 验证重建结果的完整性
   * 4. 返回重建的聚合根
   */
  static fromEvents(events: IDomainEvent[]): UserAggregate {
    const aggregate = new UserAggregate(null as any, null as any);

    for (const event of events) {
      aggregate.applyEvent(event);
    }

    return aggregate;
  }

  /**
   * @method applyEvent
   * @description 应用领域事件到聚合根，用于事件溯源状态重建
   * @param {IDomainEvent} event 领域事件
   * @returns {void}
   * @private
   *
   * 事件应用：
   * 1. 根据事件类型调用相应的应用方法
   * 2. 更新聚合根的内部状态
   * 3. 维护聚合根的版本号
   * 4. 确保状态变更的一致性
   */
  private applyEvent(event: IDomainEvent): void {
    switch (event.eventType) {
      case 'UserCreated':
        this.applyUserCreatedEvent(event as UserCreatedEvent);
        break;
      case 'UserUpdated':
        this.applyUserUpdatedEvent(event as UserUpdatedEvent);
        break;
      case 'UserDeleted':
        this.applyUserDeletedEvent(event as UserDeletedEvent);
        break;
    }

    this.version++;
  }

  /**
   * @method applyUserCreatedEvent
   * @description 应用用户创建事件
   * @param {UserCreatedEvent} event 用户创建事件
   * @returns {void}
   * @private
   */
  private applyUserCreatedEvent(event: UserCreatedEvent): void {
    this.user = new UserEntity(
      event.userId,
      event.email,
      event.password,
      event.profile,
      event.preferences,
    );
    this.tenantId = event.tenantId;
  }
}
````

### 3. 值对象 (Value Object) 示例

````typescript
/**
 * @class Email
 * @description
 * 邮箱值对象，封装邮箱地址的不变性约束、相等性判断和业务概念。
 *
 * 不变性约束：
 * 1. 邮箱地址一旦创建不可变更
 * 2. 邮箱格式必须符合RFC 5322标准
 * 3. 邮箱地址不区分大小写
 *
 * 相等性判断：
 * 1. 基于邮箱地址的标准化值进行相等性比较
 * 2. 忽略大小写差异
 * 3. 支持哈希码计算用于集合操作
 *
 * 业务概念封装：
 * 1. 封装邮箱验证逻辑
 * 2. 提供邮箱标准化方法
 * 3. 隐藏邮箱格式细节
 *
 * @property {string} value 标准化的邮箱地址值
 *
 * @example
 * ```typescript
 * const email1 = new Email('User@Example.COM');
 * const email2 = new Email('user@example.com');
 * console.log(email1.equals(email2)); // true
 * ```
 * @since 1.0.0
 */
export class Email {
  constructor(public readonly value: string) {
    this.validateEmail(value);
    this.value = this.normalizeEmail(value);
  }

  /**
   * @method equals
   * @description 比较两个邮箱对象是否相等，忽略大小写
   * @param {Email} other 另一个邮箱对象
   * @returns {boolean} 是否相等
   */
  equals(other: Email): boolean {
    return this.value.toLowerCase() === other.value.toLowerCase();
  }
}
````

### 4. 应用用例 (Use Case) 示例

````typescript
/**
 * @class CreateUserUseCase
 * @description
 * 创建用户应用用例，负责协调业务流程、协调逻辑和事务边界。
 *
 * 业务流程：
 * 1. 验证用户输入数据
 * 2. 检查邮箱唯一性
 * 3. 创建用户聚合根
 * 4. 保存到数据库
 * 5. 发布领域事件
 *
 * 协调逻辑：
 * 1. 协调多个领域服务
 * 2. 处理跨聚合的业务规则
 * 3. 管理事务边界
 * 4. 处理异常情况
 *
 * 事务边界：
 * 1. 整个用例在一个事务中执行
 * 2. 失败时回滚所有操作
 * 3. 成功后提交事务并发布事件
 *
 * @param {IUserRepository} userRepository 用户仓储接口
 * @param {ITenantRepository} tenantRepository 租户仓储接口
 * @param {IEventBus} eventBus 事件总线
 *
 * @example
 * ```typescript
 * const useCase = new CreateUserUseCase(userRepo, tenantRepo, eventBus);
 * await useCase.execute({ email: 'user@example.com', tenantId: 'tenant-123' });
 * ```
 * @since 1.0.0
 */
export class CreateUserUseCase {
  constructor(
    private userRepository: IUserRepository,
    private tenantRepository: ITenantRepository,
    private eventBus: IEventBus,
  ) {}

  /**
   * @method execute
   * @description 执行创建用户用例，协调完整的业务流程
   * @param {CreateUserCommand} command 创建用户命令
   * @returns {Promise<UserDto>} 创建的用户信息
   * @throws {ValidationError} 当输入数据无效时抛出
   * @throws {DuplicateEmailError} 当邮箱已存在时抛出
   * @throws {TenantNotFoundError} 当租户不存在时抛出
   */
  async execute(command: CreateUserCommand): Promise<UserDto> {
    // 事务边界开始
    return await this.userRepository.transaction(async () => {
      // 协调逻辑实现
    });
  }
}
````

### 5. 领域事件 (Domain Event) 示例

````typescript
/**
 * @class UserCreatedEvent
 * @description
 * 用户创建领域事件，描述事件含义、触发条件和影响范围。
 *
 * 事件含义：
 * 1. 表示用户聚合根已成功创建
 * 2. 包含用户创建时的关键信息
 * 3. 为其他聚合根提供用户创建通知
 *
 * 触发条件：
 * 1. 用户聚合根成功创建后自动触发
 * 2. 用户邮箱验证通过
 * 3. 租户关联建立成功
 *
 * 影响范围：
 * 1. 通知权限管理模块创建用户权限
 * 2. 触发欢迎邮件发送流程
 * 3. 更新用户统计信息
 * 4. 记录用户创建审计日志
 *
 * @property {string} userId 创建的用户ID
 * @property {string} email 用户邮箱地址
 * @property {string} tenantId 所属租户ID
 * @property {Date} occurredOn 事件发生时间
 *
 * @example
 * ```typescript
 * const event = new UserCreatedEvent('user-123', 'user@example.com', 'tenant-456');
 * eventBus.publish(event);
 * ```
 * @since 1.0.0
 */
export class UserCreatedEvent extends DomainEvent {
  constructor(
    public readonly userId: string,
    public readonly email: string,
    public readonly tenantId: string,
  ) {
    super(userId);
  }

  /**
   * @method getEventType
   * @description 获取事件类型标识
   * @returns {string} 事件类型
   */
  getEventType(): string {
    return 'UserCreated';
  }

  /**
   * @method toJSON
   * @description 将事件转换为JSON格式，用于序列化和存储
   * @returns {Record<string, unknown>} 事件的JSON表示
   */
  toJSON(): Record<string, unknown> {
    return {
      ...this.getBaseEventData(),
      userId: this.userId,
      email: this.email,
      tenantId: this.tenantId,
    };
  }
}
````

### 6. 领域服务 (Domain Service) 示例

````typescript
/**
 * @class UserDomainService
 * @description
 * 用户领域服务，负责处理跨聚合的业务逻辑和无状态操作。
 *
 * 跨聚合业务逻辑：
 * 1. 协调用户和租户之间的业务规则
 * 2. 处理用户和组织架构的关联关系
 * 3. 管理用户权限的复杂计算逻辑
 *
 * 无状态操作：
 * 1. 不维护任何内部状态
 * 2. 所有方法都是纯函数
 * 3. 可以安全地在多个聚合根之间共享
 * 4. 支持并发调用
 *
 * 业务规则封装：
 * 1. 封装复杂的业务计算逻辑
 * 2. 提供可重用的业务规则验证
 * 3. 隔离跨聚合的复杂业务逻辑
 *
 * @example
 * ```typescript
 * const userService = new UserDomainService();
 * const canAccess = userService.canUserAccessResource(userId, resourceId);
 * ```
 * @since 1.0.0
 */
export class UserDomainService {
  /**
   * @method canUserAccessResource
   * @description 判断用户是否可以访问指定资源，跨聚合权限计算
   * @param {string} userId 用户ID
   * @param {string} resourceId 资源ID
   * @param {string} tenantId 租户ID
   * @returns {Promise<boolean>} 是否可以访问
   *
   * 业务逻辑：
   * 1. 检查用户是否属于指定租户
   * 2. 验证用户角色权限
   * 3. 检查资源访问策略
   * 4. 考虑组织架构权限继承
   */
  async canUserAccessResource(
    userId: string,
    resourceId: string,
    tenantId: string,
  ): Promise<boolean> {
    // 跨聚合业务逻辑实现
  }

  /**
   * @method calculateUserPermissions
   * @description 计算用户权限列表，无状态权限计算
   * @param {string} userId 用户ID
   * @param {string} tenantId 租户ID
   * @returns {Promise<Permission[]>} 权限列表
   */
  async calculateUserPermissions(
    userId: string,
    tenantId: string,
  ): Promise<Permission[]> {
    // 无状态权限计算逻辑
  }
}
````

### 7. CQRS 命令 (Command) 示例

````typescript
/**
 * @class CreateUserCommand
 * @description
 * 创建用户命令，封装用户创建操作的输入参数和验证规则。
 *
 * 命令职责：
 * 1. 封装用户创建所需的所有输入参数
 * 2. 提供数据验证和格式检查
 * 3. 确保命令的不可变性和幂等性
 * 4. 支持命令的序列化和反序列化
 *
 * 数据隔离要求：
 * 1. 命令必须包含租户ID以确保数据隔离
 * 2. 验证用户邮箱在租户内的唯一性
 * 3. 确保命令执行者具有相应权限
 *
 * @property {string} email 用户邮箱地址，必填且格式验证
 * @property {string} password 用户密码，必填且强度验证
 * @property {string} firstName 用户名字，必填
 * @property {string} lastName 用户姓氏，必填
 * @property {string} tenantId 所属租户ID，必填
 * @property {string} organizationId 所属组织ID，可选
 * @property {string} departmentId 所属部门ID，可选
 * @property {string} requestedBy 请求创建的用户ID，用于权限验证
 *
 * @example
 * ```typescript
 * const command = new CreateUserCommand({
 *   email: 'user@example.com',
 *   password: 'SecurePass123!',
 *   firstName: 'John',
 *   lastName: 'Doe',
 *   tenantId: 'tenant-123',
 *   requestedBy: 'admin-456'
 * });
 * ```
 * @since 1.0.0
 */
export class CreateUserCommand {
  constructor(
    public readonly email: string,
    public readonly password: string,
    public readonly firstName: string,
    public readonly lastName: string,
    public readonly tenantId: string,
    public readonly organizationId?: string,
    public readonly departmentId?: string,
    public readonly requestedBy: string,
  ) {
    this.validate();
  }

  /**
   * @method validate
   * @description 验证命令参数的有效性
   * @returns {void}
   * @throws {ValidationError} 当参数无效时抛出
   */
  private validate(): void {
    // 参数验证逻辑
  }
}
````

### 8. CQRS 查询 (Query) 示例

````typescript
/**
 * @class GetUsersQuery
 * @description
 * 获取用户列表查询，封装用户查询操作的参数和过滤条件。
 *
 * 查询职责：
 * 1. 封装用户查询所需的所有参数
 * 2. 提供灵活的过滤和排序选项
 * 3. 支持分页和性能优化
 * 4. 确保查询结果的数据隔离
 *
 * 数据隔离要求：
 * 1. 查询必须基于租户ID进行数据隔离
 * 2. 根据查询者权限过滤可访问的数据
 * 3. 支持组织级和部门级的数据过滤
 * 4. 确保敏感信息的安全访问
 *
 * @property {string} tenantId 租户ID，必填，用于数据隔离
 * @property {string} organizationId 组织ID，可选，用于组织级过滤
 * @property {string} departmentId 部门ID，可选，用于部门级过滤
 * @property {string} status 用户状态过滤，可选
 * @property {string} searchTerm 搜索关键词，可选
 * @property {number} page 页码，默认1
 * @property {number} limit 每页数量，默认20，最大100
 * @property {string} sortBy 排序字段，默认'createdAt'
 * @property {'asc' | 'desc'} sortOrder 排序方向，默认'desc'
 * @property {string} requestedBy 请求查询的用户ID，用于权限验证
 *
 * @example
 * ```typescript
 * const query = new GetUsersQuery({
 *   tenantId: 'tenant-123',
 *   organizationId: 'org-456',
 *   status: 'ACTIVE',
 *   searchTerm: 'john',
 *   page: 1,
 *   limit: 20,
 *   requestedBy: 'user-789'
 * });
 * ```
 * @since 1.0.0
 */
export class GetUsersQuery {
  constructor(
    public readonly tenantId: string,
    public readonly organizationId?: string,
    public readonly departmentId?: string,
    public readonly status?: string,
    public readonly searchTerm?: string,
    public readonly page: number = 1,
    public readonly limit: number = 20,
    public readonly sortBy: string = 'createdAt',
    public readonly sortOrder: 'asc' | 'desc' = 'desc',
    public readonly requestedBy: string,
  ) {
    this.validate();
  }

  /**
   * @method validate
   * @description 验证查询参数的有效性
   * @returns {void}
   * @throws {ValidationError} 当参数无效时抛出
   */
  private validate(): void {
    // 参数验证逻辑
  }
}
````

### 9. CQRS 命令处理器 (Command Handler) 示例

````typescript
/**
 * @class CreateUserCommandHandler
 * @description
 * 创建用户命令处理器，负责处理用户创建命令的业务逻辑和事务管理。
 *
 * 处理器职责：
 * 1. 接收并验证创建用户命令
 * 2. 协调领域服务和仓储操作
 * 3. 管理事务边界和异常处理
 * 4. 发布领域事件和集成事件
 *
 * 业务逻辑流程：
 * 1. 验证命令参数和权限
 * 2. 检查邮箱唯一性约束
 * 3. 创建用户聚合根
 * 4. 保存到写模型数据库
 * 5. 发布用户创建事件
 * 6. 更新读模型视图
 *
 * 事务管理：
 * 1. 整个处理过程在一个事务中执行
 * 2. 失败时自动回滚所有操作
 * 3. 成功后提交事务并发布事件
 * 4. 支持分布式事务协调
 *
 * @param {IUserRepository} userRepository 用户仓储接口
 * @param {ITenantRepository} tenantRepository 租户仓储接口
 * @param {IUserDomainService} userDomainService 用户领域服务
 * @param {IEventBus} eventBus 事件总线
 * @param {IUnitOfWork} unitOfWork 工作单元
 *
 * @example
 * ```typescript
 * const handler = new CreateUserCommandHandler(
 *   userRepo, tenantRepo, userService, eventBus, unitOfWork
 * );
 * await handler.handle(createUserCommand);
 * ```
 * @since 1.0.0
 */
export class CreateUserCommandHandler {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly tenantRepository: ITenantRepository,
    private readonly userDomainService: IUserDomainService,
    private readonly eventBus: IEventBus,
    private readonly unitOfWork: IUnitOfWork,
  ) {}

  /**
   * @method handle
   * @description 处理创建用户命令，执行完整的用户创建流程
   * @param {CreateUserCommand} command 创建用户命令
   * @returns {Promise<UserCreatedResult>} 创建结果
   * @throws {ValidationError} 当命令参数无效时抛出
   * @throws {DuplicateEmailError} 当邮箱已存在时抛出
   * @throws {TenantNotFoundError} 当租户不存在时抛出
   * @throws {InsufficientPermissionError} 当权限不足时抛出
   *
   * 处理流程：
   * 1. 验证命令和权限
   * 2. 检查业务规则约束
   * 3. 创建用户聚合根
   * 4. 保存到数据库
   * 5. 发布领域事件
   * 6. 返回创建结果
   */
  async handle(command: CreateUserCommand): Promise<UserCreatedResult> {
    return await this.unitOfWork.execute(async () => {
      // 1. 验证命令和权限
      await this.validateCommand(command);

      // 2. 检查业务规则约束
      await this.checkBusinessRules(command);

      // 3. 创建用户聚合根
      const userAggregate = await this.createUserAggregate(command);

      // 4. 保存到数据库
      await this.userRepository.save(userAggregate);

      // 5. 发布领域事件
      await this.publishEvents(userAggregate);

      // 6. 返回创建结果
      return new UserCreatedResult(userAggregate.getUser().id);
    });
  }

  /**
   * @method validateCommand
   * @description 验证命令参数和权限
   * @param {CreateUserCommand} command 创建用户命令
   * @returns {Promise<void>}
   * @private
   */
  private async validateCommand(command: CreateUserCommand): Promise<void> {
    // 验证逻辑实现
  }
}
````

### 10. CQRS 查询处理器 (Query Handler) 示例

````typescript
/**
 * @class GetUsersQueryHandler
 * @description
 * 获取用户列表查询处理器，负责处理用户查询请求和优化读性能。
 *
 * 处理器职责：
 * 1. 接收并验证用户查询请求
 * 2. 从读模型数据库获取数据
 * 3. 应用数据隔离和权限过滤
 * 4. 优化查询性能和缓存策略
 *
 * 查询优化策略：
 * 1. 使用专门的读模型数据库
 * 2. 实现查询结果缓存机制
 * 3. 支持分页和索引优化
 * 4. 避免N+1查询问题
 *
 * 数据隔离实现：
 * 1. 基于租户ID进行数据隔离
 * 2. 根据用户权限过滤可访问数据
 * 3. 支持组织级和部门级过滤
 * 4. 确保敏感数据的安全访问
 *
 * @param {IUserReadRepository} userReadRepository 用户读模型仓储
 * @param {ICacheService} cacheService 缓存服务
 * @param {IPermissionService} permissionService 权限服务
 * @param {ITenantContext} tenantContext 租户上下文
 *
 * @example
 * ```typescript
 * const handler = new GetUsersQueryHandler(
 *   userReadRepo, cacheService, permissionService, tenantContext
 * );
 * const result = await handler.handle(getUsersQuery);
 * ```
 * @since 1.0.0
 */
export class GetUsersQueryHandler {
  constructor(
    private readonly userReadRepository: IUserReadRepository,
    private readonly cacheService: ICacheService,
    private readonly permissionService: IPermissionService,
    private readonly tenantContext: ITenantContext,
  ) {}

  /**
   * @method handle
   * @description 处理获取用户列表查询，返回分页的用户数据
   * @param {GetUsersQuery} query 获取用户列表查询
   * @returns {Promise<GetUsersResult>} 查询结果
   * @throws {ValidationError} 当查询参数无效时抛出
   * @throws {InsufficientPermissionError} 当权限不足时抛出
   *
   * 处理流程：
   * 1. 验证查询参数和权限
   * 2. 检查缓存中是否有结果
   * 3. 从读模型数据库查询数据
   * 4. 应用数据隔离和权限过滤
   * 5. 缓存查询结果
   * 6. 返回分页结果
   */
  async handle(query: GetUsersQuery): Promise<GetUsersResult> {
    // 1. 验证查询参数和权限
    await this.validateQuery(query);

    // 2. 生成缓存键
    const cacheKey = this.generateCacheKey(query);

    // 3. 检查缓存
    const cachedResult = await this.cacheService.get<GetUsersResult>(cacheKey);
    if (cachedResult) {
      return cachedResult;
    }

    // 4. 从读模型数据库查询
    const result = await this.userReadRepository.findUsers(query);

    // 5. 缓存查询结果
    await this.cacheService.set(cacheKey, result, 300); // 5分钟缓存

    // 6. 返回结果
    return result;
  }

  /**
   * @method validateQuery
   * @description 验证查询参数和权限
   * @param {GetUsersQuery} query 获取用户列表查询
   * @returns {Promise<void>}
   * @private
   */
  private async validateQuery(query: GetUsersQuery): Promise<void> {
    // 验证逻辑实现
  }

  /**
   * @method generateCacheKey
   * @description 生成查询缓存键
   * @param {GetUsersQuery} query 获取用户列表查询
   * @returns {string} 缓存键
   * @private
   */
  private generateCacheKey(query: GetUsersQuery): string {
    // 缓存键生成逻辑
    return `users:${query.tenantId}:${JSON.stringify(query)}`;
  }
}
````

### 11. 事件存储 (Event Store) 示例

````typescript
/**
 * @class EventStore
 * @description
 * 事件存储服务，负责管理领域事件的持久化、检索和重放功能。
 *
 * 事件存储职责：
 * 1. 持久化领域事件到事件存储数据库
 * 2. 支持事件的版本控制和并发控制
 * 3. 提供事件查询和过滤功能
 * 4. 支持事件重放和快照机制
 *
 * 事件溯源特性：
 * 1. 所有状态变更都通过事件记录
 * 2. 支持时间旅行和状态重建
 * 3. 提供完整的审计日志
 * 4. 支持事件版本管理和迁移
 *
 * 多租户支持：
 * 1. 基于租户ID进行事件隔离
 * 2. 支持租户级的事件查询
 * 3. 确保跨租户数据安全
 * 4. 支持租户级的事件归档
 *
 * @param {IEventRepository} eventRepository 事件仓储接口
 * @param {ISnapshotRepository} snapshotRepository 快照仓储接口
 * @param {ITenantContext} tenantContext 租户上下文
 *
 * @example
 * ```typescript
 * const eventStore = new EventStore(eventRepo, snapshotRepo, tenantContext);
 * await eventStore.saveEvents(aggregateId, events);
 * const events = await eventStore.getEvents(aggregateId, fromVersion);
 * ```
 * @since 1.0.0
 */
export class EventStore {
  constructor(
    private readonly eventRepository: IEventRepository,
    private readonly snapshotRepository: ISnapshotRepository,
    private readonly tenantContext: ITenantContext,
  ) {}

  /**
   * @method saveEvents
   * @description 保存聚合根的事件到事件存储
   * @param {string} aggregateId 聚合根ID
   * @param {IDomainEvent[]} events 领域事件列表
   * @param {number} expectedVersion 期望的版本号，用于乐观并发控制
   * @returns {Promise<void>}
   * @throws {ConcurrencyError} 当版本冲突时抛出
   * @throws {ValidationError} 当事件无效时抛出
   *
   * 保存流程：
   * 1. 验证事件的有效性和完整性
   * 2. 检查聚合根版本一致性
   * 3. 应用租户级数据隔离
   * 4. 持久化事件到存储
   * 5. 更新聚合根版本号
   */
  async saveEvents(
    aggregateId: string,
    events: IDomainEvent[],
    expectedVersion: number,
  ): Promise<void> {
    const tenantId = this.tenantContext.getCurrentTenantId();

    // 1. 验证事件
    this.validateEvents(events);

    // 2. 检查版本一致性
    await this.checkVersionConsistency(aggregateId, expectedVersion, tenantId);

    // 3. 保存事件
    await this.eventRepository.saveEvents(aggregateId, events, tenantId);
  }

  /**
   * @method getEvents
   * @description 获取聚合根的事件历史
   * @param {string} aggregateId 聚合根ID
   * @param {number} fromVersion 起始版本号
   * @param {number} toVersion 结束版本号，可选
   * @returns {Promise<IDomainEvent[]>} 事件列表
   */
  async getEvents(
    aggregateId: string,
    fromVersion: number = 0,
    toVersion?: number,
  ): Promise<IDomainEvent[]> {
    const tenantId = this.tenantContext.getCurrentTenantId();
    return await this.eventRepository.getEvents(
      aggregateId,
      fromVersion,
      toVersion,
      tenantId,
    );
  }

  /**
   * @method createSnapshot
   * @description 为聚合根创建快照
   * @param {string} aggregateId 聚合根ID
   * @param {any} aggregateState 聚合根状态
   * @param {number} version 版本号
   * @returns {Promise<void>}
   */
  async createSnapshot(
    aggregateId: string,
    aggregateState: any,
    version: number,
  ): Promise<void> {
    const tenantId = this.tenantContext.getCurrentTenantId();
    await this.snapshotRepository.saveSnapshot(
      aggregateId,
      aggregateState,
      version,
      tenantId,
    );
  }
}
````

### 12. 事件处理器 (Event Handler) 示例

````typescript
/**
 * @class UserCreatedEventHandler
 * @description
 * 用户创建事件处理器，负责处理用户创建事件的后续业务逻辑。
 *
 * 事件处理职责：
 * 1. 接收并处理用户创建领域事件
 * 2. 更新读模型和视图
 * 3. 触发相关的业务流程
 * 4. 处理事件处理的异常和重试
 *
 * 读模型更新：
 * 1. 更新用户列表视图
 * 2. 更新用户统计信息
 * 3. 更新组织架构视图
 * 4. 更新权限管理视图
 *
 * 业务流程触发：
 * 1. 发送欢迎邮件
 * 2. 创建用户权限
 * 3. 记录审计日志
 * 4. 更新用户统计
 *
 * @param {IUserReadRepository} userReadRepository 用户读模型仓储
 * @param {INotificationService} notificationService 通知服务
 * @param {IPermissionService} permissionService 权限服务
 * @param {IAuditService} auditService 审计服务
 *
 * @example
 * ```typescript
 * const handler = new UserCreatedEventHandler(
 *   userReadRepo, notificationService, permissionService, auditService
 * );
 * await handler.handle(userCreatedEvent);
 * ```
 * @since 1.0.0
 */
export class UserCreatedEventHandler {
  constructor(
    private readonly userReadRepository: IUserReadRepository,
    private readonly notificationService: INotificationService,
    private readonly permissionService: IPermissionService,
    private readonly auditService: IAuditService,
  ) {}

  /**
   * @method handle
   * @description 处理用户创建事件，执行后续业务逻辑
   * @param {UserCreatedEvent} event 用户创建事件
   * @returns {Promise<void>}
   * @throws {EventProcessingError} 当事件处理失败时抛出
   *
   * 处理流程：
   * 1. 验证事件的有效性
   * 2. 更新读模型视图
   * 3. 触发业务流程
   * 4. 记录处理结果
   */
  async handle(event: UserCreatedEvent): Promise<void> {
    try {
      // 1. 验证事件
      this.validateEvent(event);

      // 2. 更新读模型
      await this.updateReadModels(event);

      // 3. 触发业务流程
      await this.triggerBusinessProcesses(event);

      // 4. 记录审计日志
      await this.auditService.logEventProcessed(event);
    } catch (error) {
      // 记录处理失败
      await this.auditService.logEventProcessingFailed(event, error);
      throw new EventProcessingError(
        `Failed to process UserCreatedEvent: ${error.message}`,
      );
    }
  }

  /**
   * @method updateReadModels
   * @description 更新读模型视图
   * @param {UserCreatedEvent} event 用户创建事件
   * @returns {Promise<void>}
   * @private
   */
  private async updateReadModels(event: UserCreatedEvent): Promise<void> {
    // 更新用户列表视图
    await this.userReadRepository.addUser({
      id: event.userId,
      email: event.email,
      tenantId: event.tenantId,
      createdAt: event.occurredOn,
    });
  }

  /**
   * @method triggerBusinessProcesses
   * @description 触发相关的业务流程
   * @param {UserCreatedEvent} event 用户创建事件
   * @returns {Promise<void>}
   * @private
   */
  private async triggerBusinessProcesses(
    event: UserCreatedEvent,
  ): Promise<void> {
    // 并行执行多个业务流程
    await Promise.all([
      this.sendWelcomeEmail(event),
      this.createUserPermissions(event),
      this.updateUserStatistics(event),
    ]);
  }
}
````

### 13. 聚合根重建器 (Aggregate Rebuilder) 示例

````typescript
/**
 * @class UserAggregateRebuilder
 * @description
 * 用户聚合根重建器，负责从事件历史重建聚合根状态。
 *
 * 重建器职责：
 * 1. 从事件存储加载事件历史
 * 2. 应用事件到聚合根重建状态
 * 3. 支持快照机制优化性能
 * 4. 处理事件版本兼容性
 *
 * 性能优化：
 * 1. 使用快照机制减少事件重放
 * 2. 支持增量重建和全量重建
 * 3. 实现事件缓存机制
 * 4. 支持并行事件处理
 *
 * 版本兼容性：
 * 1. 处理事件结构变更
 * 2. 支持事件迁移和转换
 * 3. 维护向后兼容性
 * 4. 处理缺失事件的处理
 *
 * @param {IEventStore} eventStore 事件存储服务
 * @param {ISnapshotService} snapshotService 快照服务
 * @param {IEventMigrator} eventMigrator 事件迁移器
 *
 * @example
 * ```typescript
 * const rebuilder = new UserAggregateRebuilder(eventStore, snapshotService, eventMigrator);
 * const userAggregate = await rebuilder.rebuildAggregate('user-123');
 * ```
 * @since 1.0.0
 */
export class UserAggregateRebuilder {
  constructor(
    private readonly eventStore: IEventStore,
    private readonly snapshotService: ISnapshotService,
    private readonly eventMigrator: IEventMigrator,
  ) {}

  /**
   * @method rebuildAggregate
   * @description 从事件历史重建用户聚合根
   * @param {string} aggregateId 聚合根ID
   * @param {number} toVersion 目标版本号，可选
   * @returns {Promise<UserAggregate>} 重建的聚合根
   * @throws {AggregateNotFoundError} 当聚合根不存在时抛出
   * @throws {EventCorruptionError} 当事件数据损坏时抛出
   *
   * 重建流程：
   * 1. 检查是否有可用的快照
   * 2. 从快照或事件历史开始重建
   * 3. 应用事件到聚合根
   * 4. 验证重建结果的完整性
   */
  async rebuildAggregate(
    aggregateId: string,
    toVersion?: number,
  ): Promise<UserAggregate> {
    // 1. 检查快照
    const snapshot = await this.snapshotService.getLatestSnapshot(aggregateId);

    let aggregate: UserAggregate;
    let fromVersion = 0;

    if (snapshot && (!toVersion || snapshot.version < toVersion)) {
      // 从快照开始重建
      aggregate = this.createAggregateFromSnapshot(snapshot);
      fromVersion = snapshot.version + 1;
    } else {
      // 从头开始重建
      aggregate = new UserAggregate();
    }

    // 2. 获取事件历史
    const events = await this.eventStore.getEvents(
      aggregateId,
      fromVersion,
      toVersion,
    );

    // 3. 应用事件
    for (const event of events) {
      // 迁移事件到当前版本
      const migratedEvent = await this.eventMigrator.migrateEvent(event);

      // 应用事件到聚合根
      aggregate.applyEvent(migratedEvent);
    }

    // 4. 验证重建结果
    this.validateRebuiltAggregate(aggregate);

    return aggregate;
  }

  /**
   * @method createAggregateFromSnapshot
   * @description 从快照创建聚合根
   * @param {ISnapshot} snapshot 快照数据
   * @returns {UserAggregate} 聚合根实例
   * @private
   */
  private createAggregateFromSnapshot(snapshot: ISnapshot): UserAggregate {
    // 从快照数据重建聚合根状态
    return UserAggregate.fromSnapshot(snapshot.data);
  }

  /**
   * @method validateRebuiltAggregate
   * @description 验证重建的聚合根完整性
   * @param {UserAggregate} aggregate 聚合根实例
   * @returns {void}
   * @throws {AggregateCorruptionError} 当聚合根数据损坏时抛出
   * @private
   */
  private validateRebuiltAggregate(aggregate: UserAggregate): void {
    // 验证聚合根的完整性
    if (!aggregate.isValid()) {
      throw new AggregateCorruptionError(
        'Rebuilt aggregate is in invalid state',
      );
    }
  }
}
````

### 14. 事件投射器 (Event Projector) 示例

````typescript
/**
 * @class UserReadModelProjector
 * @description
 * 用户读模型事件投射器，负责将领域事件投射到读模型视图。
 *
 * 投射器职责：
 * 1. 监听和处理用户相关的领域事件
 * 2. 维护用户相关的读模型视图
 * 3. 支持投射的增量更新
 * 4. 处理投射的异常和恢复
 *
 * 读模型维护：
 * 1. 用户列表视图
 * 2. 用户统计视图
 * 3. 用户权限视图
 * 4. 用户活动视图
 *
 * 投射特性：
 * 1. 支持投射的幂等性
 * 2. 处理重复事件
 * 3. 支持投射的重新构建
 * 4. 提供投射状态查询
 *
 * 多租户支持：
 * 1. 基于租户ID进行数据隔离
 * 2. 支持租户级的读模型更新
 * 3. 确保跨租户数据安全
 * 4. 支持租户级的投射统计
 *
 * @param {IUserReadRepository} userReadRepository 用户读模型仓储
 * @param {IUserStatisticsRepository} statisticsRepository 统计仓储
 * @param {IUserPermissionRepository} permissionRepository 权限仓储
 * @param {IProjectionStateRepository} projectionStateRepository 投射状态仓储
 * @param {ITenantContext} tenantContext 租户上下文
 *
 * @example
 * ```typescript
 * const projector = new UserReadModelProjector(
 *   userReadRepo, statisticsRepo, permissionRepo, projectionStateRepo, tenantContext
 * );
 * await projector.handle(userCreatedEvent);
 * ```
 * @since 1.0.0
 */
@Injectable()
export class UserReadModelProjector {
  constructor(
    private readonly userReadRepository: IUserReadRepository,
    private readonly statisticsRepository: IUserStatisticsRepository,
    private readonly permissionRepository: IUserPermissionRepository,
    private readonly projectionStateRepository: IProjectionStateRepository,
    private readonly tenantContext: ITenantContext,
  ) {}

  /**
   * @method handle
   * @description 处理用户相关事件，更新读模型视图
   * @param {IDomainEvent} event 领域事件
   * @returns {Promise<void>}
   * @throws {ProjectionError} 当投射处理失败时抛出
   *
   * 处理流程：
   * 1. 检查事件是否已处理（幂等性）
   * 2. 根据事件类型更新相应视图
   * 3. 记录投射处理状态
   * 4. 处理投射异常
   */
  async handle(event: IDomainEvent): Promise<void> {
    try {
      // 1. 检查事件是否已处理（幂等性）
      if (await this.isEventProcessed(event)) {
        return;
      }

      // 2. 根据事件类型处理
      switch (event.eventType) {
        case 'UserCreated':
          await this.handleUserCreated(event as UserCreatedEvent);
          break;
        case 'UserUpdated':
          await this.handleUserUpdated(event as UserUpdatedEvent);
          break;
        case 'UserDeleted':
          await this.handleUserDeleted(event as UserDeletedEvent);
          break;
        default:
          // 忽略不相关的事件
          break;
      }

      // 3. 记录事件处理状态
      await this.recordEventProcessed(event);
    } catch (error) {
      // 记录投射处理失败
      await this.recordProjectionError(event, error);
      throw new ProjectionError(
        `Failed to process event ${event.eventType}: ${error.message}`,
      );
    }
  }

  /**
   * @method handleUserCreated
   * @description 处理用户创建事件
   * @param {UserCreatedEvent} event 用户创建事件
   * @returns {Promise<void>}
   * @private
   *
   * 处理流程：
   * 1. 更新用户列表视图
   * 2. 更新用户统计信息
   * 3. 创建默认权限
   * 4. 应用租户级数据隔离
   */
  private async handleUserCreated(event: UserCreatedEvent): Promise<void> {
    const tenantId = this.tenantContext.getCurrentTenantId();

    // 更新用户列表视图
    await this.userReadRepository.addUser({
      id: event.userId,
      email: event.email,
      tenantId: event.tenantId,
      createdAt: event.occurredOn,
      status: 'ACTIVE',
    });

    // 更新用户统计
    await this.statisticsRepository.incrementUserCount(tenantId);

    // 创建默认权限
    await this.permissionRepository.createDefaultPermissions(
      event.userId,
      tenantId,
    );
  }

  /**
   * @method isEventProcessed
   * @description 检查事件是否已处理
   * @param {IDomainEvent} event 领域事件
   * @returns {Promise<boolean>} 是否已处理
   * @private
   */
  private async isEventProcessed(event: IDomainEvent): Promise<boolean> {
    return await this.projectionStateRepository.isEventProcessed(
      'UserReadModelProjector',
      event.getEventId(),
    );
  }

  /**
   * @method recordEventProcessed
   * @description 记录事件处理状态
   * @param {IDomainEvent} event 领域事件
   * @returns {Promise<void>}
   * @private
   */
  private async recordEventProcessed(event: IDomainEvent): Promise<void> {
    await this.projectionStateRepository.recordEventProcessed(
      'UserReadModelProjector',
      event.getEventId(),
      event.occurredOn,
    );
  }
}
````

### 15. 事件投影 (Event Projection) 示例

````typescript
/**
 * @class UserProjection
 * @description
 * 用户事件投影，负责将领域事件投影到读模型视图。
 *
 * 投影职责：
 * 1. 监听和处理用户相关的领域事件
 * 2. 维护用户相关的读模型视图
 * 3. 支持投影的增量更新
 * 4. 处理投影的异常和恢复
 *
 * 读模型维护：
 * 1. 用户列表视图
 * 2. 用户统计视图
 * 3. 用户权限视图
 * 4. 用户活动视图
 *
 * 投影特性：
 * 1. 支持投影的幂等性
 * 2. 处理重复事件
 * 3. 支持投影的重新构建
 * 4. 提供投影状态查询
 *
 * @param {IUserReadRepository} userReadRepository 用户读模型仓储
 * @param {IUserStatisticsRepository} statisticsRepository 统计仓储
 * @param {IUserPermissionRepository} permissionRepository 权限仓储
 * @param {IProjectionStateRepository} projectionStateRepository 投影状态仓储
 *
 * @example
 * ```typescript
 * const projection = new UserProjection(
 *   userReadRepo, statisticsRepo, permissionRepo, projectionStateRepo
 * );
 * await projection.handle(userCreatedEvent);
 * ```
 * @since 1.0.0
 */
export class UserProjection {
  constructor(
    private readonly userReadRepository: IUserReadRepository,
    private readonly statisticsRepository: IUserStatisticsRepository,
    private readonly permissionRepository: IUserPermissionRepository,
    private readonly projectionStateRepository: IProjectionStateRepository,
  ) {}

  /**
   * @method handle
   * @description 处理用户相关事件，更新读模型视图
   * @param {IDomainEvent} event 领域事件
   * @returns {Promise<void>}
   * @throws {ProjectionError} 当投影处理失败时抛出
   *
   * 处理流程：
   * 1. 检查事件是否已处理
   * 2. 根据事件类型更新相应视图
   * 3. 记录投影处理状态
   * 4. 处理投影异常
   */
  async handle(event: IDomainEvent): Promise<void> {
    try {
      // 1. 检查事件是否已处理（幂等性）
      if (await this.isEventProcessed(event)) {
        return;
      }

      // 2. 根据事件类型处理
      switch (event.getEventType()) {
        case 'UserCreated':
          await this.handleUserCreated(event as UserCreatedEvent);
          break;
        case 'UserUpdated':
          await this.handleUserUpdated(event as UserUpdatedEvent);
          break;
        case 'UserDeleted':
          await this.handleUserDeleted(event as UserDeletedEvent);
          break;
        default:
          // 忽略不相关的事件
          break;
      }

      // 3. 记录事件处理状态
      await this.recordEventProcessed(event);
    } catch (error) {
      // 记录投影处理失败
      await this.recordProjectionError(event, error);
      throw new ProjectionError(
        `Failed to process event ${event.getEventType()}: ${error.message}`,
      );
    }
  }

  /**
   * @method handleUserCreated
   * @description 处理用户创建事件
   * @param {UserCreatedEvent} event 用户创建事件
   * @returns {Promise<void>}
   * @private
   */
  private async handleUserCreated(event: UserCreatedEvent): Promise<void> {
    // 更新用户列表视图
    await this.userReadRepository.addUser({
      id: event.userId,
      email: event.email,
      tenantId: event.tenantId,
      createdAt: event.occurredOn,
      status: 'ACTIVE',
    });

    // 更新用户统计
    await this.statisticsRepository.incrementUserCount(event.tenantId);

    // 创建默认权限
    await this.permissionRepository.createDefaultPermissions(
      event.userId,
      event.tenantId,
    );
  }

  /**
   * @method isEventProcessed
   * @description 检查事件是否已处理
   * @param {IDomainEvent} event 领域事件
   * @returns {Promise<boolean>} 是否已处理
   * @private
   */
  private async isEventProcessed(event: IDomainEvent): Promise<boolean> {
    return await this.projectionStateRepository.isEventProcessed(
      'UserProjection',
      event.getEventId(),
    );
  }

  /**
   * @method recordEventProcessed
   * @description 记录事件处理状态
   * @param {IDomainEvent} event 领域事件
   * @returns {Promise<void>}
   * @private
   */
  private async recordEventProcessed(event: IDomainEvent): Promise<void> {
    await this.projectionStateRepository.recordEventProcessed(
      'UserProjection',
      event.getEventId(),
      event.occurredOn,
    );
  }
}
````

### 16. 数据库适配器 (Database Adapter) 示例

````typescript
/**
 * @class PostgreSQLAdapter
 * @description PostgreSQL数据库适配器，提供统一的数据库操作接口。
 *
 * 适配器职责：
 * 1. 实现PostgreSQL数据库的连接管理
 * 2. 提供统一的查询和事务接口
 * 3. 支持连接池和性能监控
 * 4. 实现多租户数据隔离支持
 *
 * 多租户支持：
 * 1. 支持租户上下文设置
 * 2. 支持Schema级隔离
 * 3. 支持行级安全策略
 * 4. 提供租户级连接管理
 *
 * 性能监控：
 * 1. 查询性能统计
 * 2. 连接池状态监控
 * 3. 健康检查机制
 * 4. 事件通知系统
 *
 * 隔离策略支持：
 * 1. 数据库级隔离：每个租户使用独立的数据库
 * 2. Schema级隔离：每个租户使用独立的Schema
 * 3. 表级隔离：所有租户共享数据库，通过tenant_id字段隔离
 *
 * @param {DatabaseConfig} config 数据库配置
 * @param {string} name 适配器名称
 * @param {EventEmitter2} eventEmitter 事件发射器
 * @param {PinoLoggerService} logger 日志服务
 *
 * @example
 * ```typescript
 * const adapter = new PostgreSQLAdapter(config, 'main-db', eventEmitter, logger);
 * await adapter.connect();
 * const result = await adapter.query('SELECT * FROM users WHERE id = $1', ['user-123']);
 * ```
 * @since 1.0.0
 */
@Injectable()
export class PostgreSQLAdapter implements IDatabaseAdapter {
  public readonly name: string;
  public readonly type: string = 'postgresql';
  public readonly eventEmitter: EventEmitter2;
  public readonly config: DatabaseConfig;

  private tenantId?: string;
  private defaultSchema?: string;
  private rlsEnabled: boolean = false;
  private pool: Pool;
  private knexInstance: Knex;
  private isConnectedFlag = false;
  private stats: DatabaseStats;

  constructor(
    @Inject('DATABASE_CONFIG') config: DatabaseConfig,
    @Inject('DATABASE_NAME') name: string,
    eventEmitter: EventEmitter2,
    logger: PinoLoggerService,
  ) {
    this.config = config;
    this.name = name;
    this.eventEmitter = eventEmitter;
    this.logger = logger;
    this.stats = this.initializeStats();
    this.initializePool();
    this.initializeKnex();
  }

  /**
   * @method connect
   * @description 连接到PostgreSQL数据库
   * @returns {Promise<void>} 连接结果
   * @throws {DatabaseConnectionError} 当连接失败时抛出
   *
   * 连接流程：
   * 1. 初始化连接池
   * 2. 测试数据库连接
   * 3. 设置连接状态
   * 4. 发射连接事件
   */
  async connect(): Promise<void> {
    try {
      this.logger.info(
        `Connecting to PostgreSQL database: ${this.config.database}`,
        LogContext.DATABASE,
        { adapter: this.name, host: this.config.host, port: this.config.port },
      );

      // 测试连接池连接
      const client = await this.pool.connect();
      await client.query('SELECT 1');
      client.release();

      this.isConnectedFlag = true;

      this.emitEvent('connected', {
        adapter: this.name,
        database: this.config.database,
        timestamp: new Date(),
      });
    } catch (error) {
      this.isConnectedFlag = false;
      this.logger.error(
        `Failed to connect to PostgreSQL database: ${this.config.database}`,
        LogContext.DATABASE,
        { adapter: this.name, error: (error as Error).message },
        error as Error,
      );

      this.emitEvent('connection_error', {
        adapter: this.name,
        error: (error as Error).message,
        timestamp: new Date(),
      });

      throw error;
    }
  }

  /**
   * @method query
   * @description 执行查询
   * @param {string} sql SQL语句
   * @param {unknown[]} params 查询参数
   * @param {QueryOptions} options 查询选项
   * @returns {Promise<QueryResult>} 查询结果
   * @throws {QueryExecutionError} 当查询执行失败时抛出
   *
   * 查询流程：
   * 1. 记录查询开始时间
   * 2. 执行SQL查询
   * 3. 更新统计信息
   * 4. 发射查询事件
   */
  async query(
    sql: string,
    params: unknown[] = [],
    options: QueryOptions = {},
  ): Promise<QueryResult> {
    const startTime = Date.now();
    this.stats.totalQueries++;

    try {
      if (options.logQuery) {
        this.logger.debug(`Executing query: ${sql}`, LogContext.DATABASE, {
          adapter: this.name,
          params,
          tag: options.tag,
        });
      }

      const queryConfig = {
        text: sql,
        values: params,
        name: options.tag ?? 'unnamed',
      };

      const result = await this.pool.query(queryConfig);
      const responseTime = Date.now() - startTime;

      this.updateStats(responseTime, true);

      this.emitEvent('query_executed', {
        adapter: this.name,
        sql,
        params,
        responseTime,
        rowCount: result.rowCount,
        timestamp: new Date(),
      });

      return result;
    } catch (error) {
      const responseTime = Date.now() - startTime;
      this.updateStats(responseTime, false);

      this.logger.error(
        `Query failed: ${sql}`,
        LogContext.DATABASE,
        {
          adapter: this.name,
          params,
          responseTime,
          error: (error as Error).message,
        },
        error as Error,
      );

      this.emitEvent('query_error', {
        adapter: this.name,
        sql,
        params,
        error: (error as Error).message,
        responseTime,
        timestamp: new Date(),
      });

      throw error;
    }
  }

  /**
   * @method setTenantContext
   * @description 设置租户上下文
   * @param {string} tenantId 租户ID
   */
  setTenantContext(tenantId: string): void {
    this.tenantId = tenantId;
  }

  /**
   * @method getTenantContext
   * @description 获取租户上下文
   * @returns {string | undefined} 租户ID
   */
  getTenantContext(): string | undefined {
    return this.tenantId;
  }

  /**
   * @method setDefaultSchema
   * @description 设置默认Schema
   * @param {string} schemaName Schema名称
   */
  setDefaultSchema(schemaName: string): void {
    this.defaultSchema = schemaName;
  }

  /**
   * @method getDefaultSchema
   * @description 获取默认Schema
   * @returns {string | undefined} Schema名称
   */
  getDefaultSchema(): string | undefined {
    return this.defaultSchema;
  }

  /**
   * @method enableRowLevelSecurity
   * @description 启用行级安全策略
   */
  enableRowLevelSecurity(): void {
    this.rlsEnabled = true;
  }

  /**
   * @method disableRowLevelSecurity
   * @description 禁用行级安全策略
   */
  disableRowLevelSecurity(): void {
    this.rlsEnabled = false;
  }

  /**
   * @method isRowLevelSecurityEnabled
   * @description 检查是否启用了行级安全策略
   * @returns {boolean} 是否启用RLS
   */
  isRowLevelSecurityEnabled(): boolean {
    return this.rlsEnabled;
  }
}
````

### 17. 租户感知仓储 (Tenant-Aware Repository) 示例

````typescript
/**
 * @class TenantAwareRepository
 * @description 租户感知的仓储基类，根据隔离策略配置自动处理租户数据隔离。
 *
 * 仓储职责：
 * 1. 提供统一的数据访问接口
 * 2. 根据隔离策略自动处理租户数据隔离
 * 3. 支持多种隔离策略（数据库级、Schema级、表级）
 * 4. 提供租户特定的仓储实例创建
 *
 * 隔离策略支持：
 * 1. 数据库级隔离：每个租户使用独立的数据库
 * 2. Schema级隔离：每个租户使用独立的Schema
 * 3. 表级隔离：所有租户共享数据库，通过tenant_id字段隔离
 *
 * 多租户功能：
 * 1. 自动添加租户隔离条件
 * 2. 支持租户上下文切换
 * 3. 提供租户特定的数据操作
 * 4. 确保数据隔离的安全性
 *
 * @template T 实体类型
 * @param {DatabaseAdapterFactory} adapterFactory 数据库适配器工厂
 * @param {IsolationConfigService} isolationConfig 隔离配置服务
 * @param {string} [tenantId] 租户ID，可选
 *
 * @example
 * ```typescript
 * class UserRepository extends TenantAwareRepository<User> {
 *   protected getTableName(): string {
 *     return 'users';
 *   }
 * }
 *
 * const userRepo = new UserRepository(adapterFactory, isolationConfig, 'tenant-123');
 * const users = await userRepo.findAll();
 * ```
 * @since 1.0.0
 */
export abstract class TenantAwareRepository<T> {
  protected adapter: IDatabaseAdapter;

  constructor(
    protected readonly adapterFactory: DatabaseAdapterFactory,
    protected readonly isolationConfig: IsolationConfigService,
    protected readonly tenantId?: string,
  ) {
    this.adapter = this.adapterFactory.createAdapter(tenantId);
  }

  /**
   * @method findAll
   * @description 查找所有记录，自动应用租户隔离条件
   * @param {object} [options] 查询选项
   * @returns {Promise<T[]>} 记录列表
   *
   * 查询流程：
   * 1. 构建基础查询语句
   * 2. 根据隔离策略添加租户条件
   * 3. 添加排序和分页条件
   * 4. 执行查询并返回结果
   */
  async findAll(options?: {
    limit?: number;
    offset?: number;
    orderBy?: string;
  }): Promise<T[]> {
    let query = `SELECT * FROM ${this.getTableName()}`;

    // 根据隔离策略添加条件
    query = this.addIsolationConditions(query);

    // 添加排序
    if (options?.orderBy) {
      query += ` ORDER BY ${options.orderBy}`;
    }

    // 添加分页
    if (options?.limit) {
      query += ` LIMIT ${options.limit}`;
      if (options?.offset) {
        query += ` OFFSET ${options.offset}`;
      }
    }

    const result = await this.adapter.query(query);
    return result.rows;
  }

  /**
   * @method findById
   * @description 根据ID查找记录，自动应用租户隔离条件
   * @param {string} id 记录ID
   * @returns {Promise<T | null>} 记录或null
   */
  async findById(id: string): Promise<T | null> {
    let query = `SELECT * FROM ${this.getTableName()} WHERE id = $1`;

    // 根据隔离策略添加条件
    query = this.addIsolationConditions(query);

    const result = await this.adapter.query(query, [id]);
    return result.rows[0] || null;
  }

  /**
   * @method create
   * @description 创建新记录，自动添加租户信息
   * @param {Partial<T>} data 记录数据
   * @returns {Promise<T>} 创建的记录
   *
   * 创建流程：
   * 1. 获取当前租户ID
   * 2. 为表级隔离添加tenant_id字段
   * 3. 构建INSERT语句
   * 4. 执行插入并返回结果
   */
  async create(data: Partial<T>): Promise<T> {
    const tenantId = this.tenantId || this.isolationConfig.getDefaultTenantId();

    // 为表级隔离添加tenant_id
    if (this.isolationConfig.isTableLevel()) {
      const tenantIdField = this.isolationConfig.getTenantIdField();
      (data as any)[tenantIdField] = tenantId;
    }

    const fields = Object.keys(data);
    const values = Object.values(data);
    const placeholders = fields.map((_, index) => `$${index + 1}`).join(', ');

    const query = `
      INSERT INTO ${this.getTableName()} (${fields.join(', ')})
      VALUES (${placeholders})
      RETURNING *
    `;

    const result = await this.adapter.query(query, values);
    return result.rows[0];
  }

  /**
   * @method addIsolationConditions
   * @description 根据隔离策略添加隔离条件
   * @param {string} query 原始查询
   * @returns {string} 修改后的查询
   * @protected
   *
   * 隔离条件添加：
   * 1. 表级隔离：添加WHERE tenant_id = 'tenant-id'条件
   * 2. Schema级隔离：通过适配器处理，不修改查询
   * 3. 数据库级隔离：通过适配器处理，不修改查询
   */
  protected addIsolationConditions(query: string): string {
    if (!this.tenantId) {
      return query;
    }

    const strategy = this.isolationConfig.getStrategy();

    switch (strategy) {
      case IsolationStrategy.TABLE_LEVEL:
        if (this.isolationConfig.shouldAutoAddTenantCondition()) {
          const tenantIdField = this.isolationConfig.getTenantIdField();
          if (!query.toLowerCase().includes('where')) {
            return `${query} WHERE ${tenantIdField} = '${this.tenantId}'`;
          } else {
            return `${query} AND ${tenantIdField} = '${this.tenantId}'`;
          }
        }
        break;

      case IsolationStrategy.SCHEMA_LEVEL:
        // Schema级隔离通过适配器处理，这里不需要修改查询
        break;

      case IsolationStrategy.DATABASE_LEVEL:
        // 数据库级隔离通过适配器处理，这里不需要修改查询
        break;
    }

    return query;
  }

  /**
   * @method getTableName
   * @description 获取表名（子类必须实现）
   * @returns {string} 表名
   * @abstract
   */
  protected abstract getTableName(): string;

  /**
   * @method setTenantId
   * @description 设置租户ID并重新创建适配器
   * @param {string} tenantId 租户ID
   */
  setTenantId(tenantId: string): void {
    (this as any).tenantId = tenantId;
    this.adapter = this.adapterFactory.createAdapter(tenantId);
  }

  /**
   * @method createTenantSpecificRepository
   * @description 创建特定租户的仓储实例
   * @param {string} tenantId 租户ID
   * @returns {TenantAwareRepository<T>} 新的仓储实例
   */
  createTenantSpecificRepository(tenantId: string): TenantAwareRepository<T> {
    const RepositoryClass = this.constructor as new (
      adapterFactory: DatabaseAdapterFactory,
      isolationConfig: IsolationConfigService,
      tenantId?: string,
    ) => TenantAwareRepository<T>;

    return new RepositoryClass(
      this.adapterFactory,
      this.isolationConfig,
      tenantId,
    );
  }
}
````

### 18. 数据库适配器工厂 (Database Adapter Factory) 示例

````typescript
/**
 * @class DatabaseAdapterFactory
 * @description 数据库适配器工厂，负责根据隔离策略动态创建数据库适配器。
 *
 * 工厂职责：
 * 1. 根据隔离策略创建相应的数据库适配器
 * 2. 管理适配器的配置和连接
 * 3. 支持多种隔离策略的动态切换
 * 4. 提供统一的适配器创建接口
 *
 * 隔离策略支持：
 * 1. 数据库级隔离：为每个租户创建独立的数据库连接
 * 2. Schema级隔离：为每个租户创建独立的Schema连接
 * 3. 表级隔离：所有租户共享数据库连接，通过tenant_id隔离
 *
 * 配置管理：
 * 1. 动态读取隔离策略配置
 * 2. 根据策略生成相应的连接配置
 * 3. 支持租户特定的配置覆盖
 * 4. 提供配置验证和错误处理
 *
 * @param {IsolationConfigService} isolationConfig 隔离配置服务
 *
 * @example
 * ```typescript
 * const factory = new DatabaseAdapterFactory(isolationConfig);
 * const adapter = factory.createAdapter('tenant-123');
 * await adapter.connect();
 * ```
 * @since 1.0.0
 */
export class DatabaseAdapterFactory {
  constructor(private readonly isolationConfig: IsolationConfigService) {}

  /**
   * @method createAdapter
   * @description 根据隔离策略创建数据库适配器
   * @param {string} [tenantId] 租户ID，可选
   * @returns {IDatabaseAdapter} 数据库适配器实例
   * @throws {UnsupportedIsolationStrategyError} 当隔离策略不支持时抛出
   *
   * 创建流程：
   * 1. 获取当前隔离策略
   * 2. 根据策略生成连接配置
   * 3. 创建相应的适配器实例
   * 4. 返回配置好的适配器
   */
  createAdapter(tenantId?: string): IDatabaseAdapter {
    const strategy = this.isolationConfig.getStrategy();
    const connectionConfig = this.isolationConfig.getConnectionConfig(tenantId);

    switch (strategy) {
      case IsolationStrategy.DATABASE_LEVEL:
        return this.createDatabaseLevelAdapter(connectionConfig);
      case IsolationStrategy.SCHEMA_LEVEL:
        return this.createSchemaLevelAdapter(connectionConfig);
      case IsolationStrategy.TABLE_LEVEL:
        return this.createTableLevelAdapter(connectionConfig);
      default:
        throw new Error(`Unsupported isolation strategy: ${String(strategy)}`);
    }
  }

  /**
   * @method createDatabaseLevelAdapter
   * @description 创建数据库级隔离适配器
   * @param {object} connectionConfig 连接配置
   * @returns {IDatabaseAdapter} 数据库适配器
   * @private
   *
   * 数据库级隔离特点：
   * 1. 每个租户使用独立的数据库
   * 2. 完全的数据隔离
   * 3. 需要为每个租户创建数据库
   * 4. 连接配置包含租户特定的数据库名
   */
  private createDatabaseLevelAdapter(connectionConfig: {
    database: string;
    tenantId?: string;
  }): IDatabaseAdapter {
    const config: DatabaseConfig = {
      type: 'postgresql',
      host: this.isolationConfig.getHost(),
      port: this.isolationConfig.getPort(),
      username: this.isolationConfig.getUsername(),
      password: this.isolationConfig.getPassword(),
      database: connectionConfig.database,
      pool: this.isolationConfig.getPoolConfig(),
    };

    return new PostgreSQLAdapter(
      config,
      `db-${connectionConfig.tenantId}`,
      this.eventEmitter,
      this.logger,
    );
  }

  /**
   * @method createSchemaLevelAdapter
   * @description 创建Schema级隔离适配器
   * @param {object} connectionConfig 连接配置
   * @returns {IDatabaseAdapter} 数据库适配器
   * @private
   *
   * Schema级隔离特点：
   * 1. 每个租户使用独立的Schema
   * 2. 共享数据库实例
   * 3. 通过Schema名称进行隔离
   * 4. 连接配置包含租户特定的Schema名
   */
  private createSchemaLevelAdapter(connectionConfig: {
    database: string;
    schema?: string;
    tenantId?: string;
  }): IDatabaseAdapter {
    const config: DatabaseConfig = {
      type: 'postgresql',
      host: this.isolationConfig.getHost(),
      port: this.isolationConfig.getPort(),
      username: this.isolationConfig.getUsername(),
      password: this.isolationConfig.getPassword(),
      database: connectionConfig.database,
      schema: connectionConfig.schema,
      pool: this.isolationConfig.getPoolConfig(),
    };

    const adapter = new PostgreSQLAdapter(
      config,
      `schema-${connectionConfig.tenantId}`,
      this.eventEmitter,
      this.logger,
    );

    // 设置默认Schema
    if (connectionConfig.schema) {
      adapter.setDefaultSchema(connectionConfig.schema);
    }

    return adapter;
  }

  /**
   * @method createTableLevelAdapter
   * @description 创建表级隔离适配器
   * @param {object} connectionConfig 连接配置
   * @returns {IDatabaseAdapter} 数据库适配器
   * @private
   *
   * 表级隔离特点：
   * 1. 所有租户共享数据库和Schema
   * 2. 通过tenant_id字段进行隔离
   * 3. 支持行级安全策略
   * 4. 连接配置使用默认数据库
   */
  private createTableLevelAdapter(connectionConfig: {
    database: string;
    tenantId?: string;
  }): IDatabaseAdapter {
    const config: DatabaseConfig = {
      type: 'postgresql',
      host: this.isolationConfig.getHost(),
      port: this.isolationConfig.getPort(),
      username: this.isolationConfig.getUsername(),
      password: this.isolationConfig.getPassword(),
      database: connectionConfig.database,
      pool: this.isolationConfig.getPoolConfig(),
    };

    const adapter = new PostgreSQLAdapter(
      config,
      'table-level',
      this.eventEmitter,
      this.logger,
    );

    // 设置租户上下文
    if (connectionConfig.tenantId) {
      adapter.setTenantContext(connectionConfig.tenantId);
    }

    // 启用行级安全策略
    if (this.isolationConfig.isRowLevelSecurityEnabled()) {
      adapter.enableRowLevelSecurity();
    }

    return adapter;
  }
}
````

### 19. 数据库适配器 (Database Adapter) 示例

````typescript
/**
 * @class PostgreSQLAdapter
 * @description PostgreSQL数据库适配器，提供统一的数据库操作接口。
 *
 * 适配器职责：
 * 1. 实现PostgreSQL数据库的连接管理
 * 2. 提供统一的查询和事务接口
 * 3. 支持连接池和性能监控
 * 4. 实现多租户数据隔离支持
 *
 * 多租户支持：
 * 1. 支持租户上下文设置
 * 2. 支持Schema级隔离
 * 3. 支持行级安全策略
 * 4. 提供租户级连接管理
 *
 * 性能监控：
 * 1. 查询性能统计
 * 2. 连接池状态监控
 * 3. 健康检查机制
 * 4. 事件通知系统
 *
 * @param {DatabaseConfig} config 数据库配置
 * @param {string} name 适配器名称
 * @param {EventEmitter2} eventEmitter 事件发射器
 * @param {PinoLoggerService} logger 日志服务
 *
 * @example
 * ```typescript
 * const adapter = new PostgreSQLAdapter(config, 'main-db', eventEmitter, logger);
 * await adapter.connect();
 * const result = await adapter.query('SELECT * FROM users WHERE id = $1', ['user-123']);
 * ```
 * @since 1.0.0
 */
@Injectable()
export class PostgreSQLAdapter implements IDatabaseAdapter {
  public readonly name: string;
  public readonly type: string = 'postgresql';
  public readonly eventEmitter: EventEmitter2;
  public readonly config: DatabaseConfig;

  private tenantId?: string;
  private defaultSchema?: string;
  private rlsEnabled: boolean = false;
  private pool: Pool;
  private knexInstance: Knex;
  private isConnectedFlag = false;
  private stats: DatabaseStats;

  constructor(
    @Inject('DATABASE_CONFIG') config: DatabaseConfig,
    @Inject('DATABASE_NAME') name: string,
    eventEmitter: EventEmitter2,
    logger: PinoLoggerService,
  ) {
    this.config = config;
    this.name = name;
    this.eventEmitter = eventEmitter;
    this.logger = logger;
    this.stats = this.initializeStats();
    this.initializePool();
    this.initializeKnex();
  }

  /**
   * @method connect
   * @description 连接到PostgreSQL数据库
   * @returns {Promise<void>} 连接结果
   * @throws {DatabaseConnectionError} 当连接失败时抛出
   *
   * 连接流程：
   * 1. 初始化连接池
   * 2. 测试数据库连接
   * 3. 设置连接状态
   * 4. 发射连接事件
   */
  async connect(): Promise<void> {
    try {
      this.logger.info(
        `Connecting to PostgreSQL database: ${this.config.database}`,
        LogContext.DATABASE,
        { adapter: this.name, host: this.config.host, port: this.config.port },
      );

      // 测试连接池连接
      const client = await this.pool.connect();
      await client.query('SELECT 1');
      client.release();

      this.isConnectedFlag = true;

      this.emitEvent('connected', {
        adapter: this.name,
        database: this.config.database,
        timestamp: new Date(),
      });
    } catch (error) {
      this.isConnectedFlag = false;
      this.logger.error(
        `Failed to connect to PostgreSQL database: ${this.config.database}`,
        LogContext.DATABASE,
        { adapter: this.name, error: (error as Error).message },
        error as Error,
      );

      this.emitEvent('connection_error', {
        adapter: this.name,
        error: (error as Error).message,
        timestamp: new Date(),
      });

      throw error;
    }
  }

  /**
   * @method query
   * @description 执行查询
   * @param {string} sql SQL语句
   * @param {unknown[]} params 查询参数
   * @param {QueryOptions} options 查询选项
   * @returns {Promise<QueryResult>} 查询结果
   * @throws {QueryExecutionError} 当查询执行失败时抛出
   *
   * 查询流程：
   * 1. 记录查询开始时间
   * 2. 执行SQL查询
   * 3. 更新统计信息
   * 4. 发射查询事件
   */
  async query(
    sql: string,
    params: unknown[] = [],
    options: QueryOptions = {},
  ): Promise<QueryResult> {
    const startTime = Date.now();
    this.stats.totalQueries++;

    try {
      if (options.logQuery) {
        this.logger.debug(`Executing query: ${sql}`, LogContext.DATABASE, {
          adapter: this.name,
          params,
          tag: options.tag,
        });
      }

      const queryConfig = {
        text: sql,
        values: params,
        name: options.tag ?? 'unnamed',
      };

      const result = await this.pool.query(queryConfig);
      const responseTime = Date.now() - startTime;

      this.updateStats(responseTime, true);

      this.emitEvent('query_executed', {
        adapter: this.name,
        sql,
        params,
        responseTime,
        rowCount: result.rowCount,
        timestamp: new Date(),
      });

      return result;
    } catch (error) {
      const responseTime = Date.now() - startTime;
      this.updateStats(responseTime, false);

      this.logger.error(
        `Query failed: ${sql}`,
        LogContext.DATABASE,
        {
          adapter: this.name,
          params,
          responseTime,
          error: (error as Error).message,
        },
        error as Error,
      );

      this.emitEvent('query_error', {
        adapter: this.name,
        sql,
        params,
        error: (error as Error).message,
        responseTime,
        timestamp: new Date(),
      });

      throw error;
    }
  }

  /**
   * @method setTenantContext
   * @description 设置租户上下文
   * @param {string} tenantId 租户ID
   */
  setTenantContext(tenantId: string): void {
    this.tenantId = tenantId;
  }

  /**
   * @method getTenantContext
   * @description 获取租户上下文
   * @returns {string | undefined} 租户ID
   */
  getTenantContext(): string | undefined {
    return this.tenantId;
  }

  /**
   * @method setDefaultSchema
   * @description 设置默认Schema
   * @param {string} schemaName Schema名称
   */
  setDefaultSchema(schemaName: string): void {
    this.defaultSchema = schemaName;
  }

  /**
   * @method getDefaultSchema
   * @description 获取默认Schema
   * @returns {string | undefined} Schema名称
   */
  getDefaultSchema(): string | undefined {
    return this.defaultSchema;
  }

  /**
   * @method enableRowLevelSecurity
   * @description 启用行级安全策略
   */
  enableRowLevelSecurity(): void {
    this.rlsEnabled = true;
  }

  /**
   * @method disableRowLevelSecurity
   * @description 禁用行级安全策略
   */
  disableRowLevelSecurity(): void {
    this.rlsEnabled = false;
  }

  /**
   * @method isRowLevelSecurityEnabled
   * @description 检查是否启用了行级安全策略
   * @returns {boolean} 是否启用RLS
   */
  isRowLevelSecurityEnabled(): boolean {
    return this.rlsEnabled;
  }
}
````

### 16. 租户感知仓储 (Tenant-Aware Repository) 示例

````typescript
/**
 * @class TenantAwareRepository
 * @description 租户感知的仓储基类，根据隔离策略配置自动处理租户数据隔离。
 *
 * 仓储职责：
 * 1. 提供统一的数据访问接口
 * 2. 根据隔离策略自动处理租户数据隔离
 * 3. 支持多种隔离策略（数据库级、Schema级、表级）
 * 4. 提供租户特定的仓储实例创建
 *
 * 隔离策略支持：
 * 1. 数据库级隔离：每个租户使用独立的数据库
 * 2. Schema级隔离：每个租户使用独立的Schema
 * 3. 表级隔离：所有租户共享数据库，通过tenant_id字段隔离
 *
 * 多租户功能：
 * 1. 自动添加租户隔离条件
 * 2. 支持租户上下文切换
 * 3. 提供租户特定的数据操作
 * 4. 确保数据隔离的安全性
 *
 * @template T 实体类型
 * @param {DatabaseAdapterFactory} adapterFactory 数据库适配器工厂
 * @param {IsolationConfigService} isolationConfig 隔离配置服务
 * @param {string} [tenantId] 租户ID，可选
 *
 * @example
 * ```typescript
 * class UserRepository extends TenantAwareRepository<User> {
 *   protected getTableName(): string {
 *     return 'users';
 *   }
 * }
 *
 * const userRepo = new UserRepository(adapterFactory, isolationConfig, 'tenant-123');
 * const users = await userRepo.findAll();
 * ```
 * @since 1.0.0
 */
export abstract class TenantAwareRepository<T> {
  protected adapter: IDatabaseAdapter;

  constructor(
    protected readonly adapterFactory: DatabaseAdapterFactory,
    protected readonly isolationConfig: IsolationConfigService,
    protected readonly tenantId?: string,
  ) {
    this.adapter = this.adapterFactory.createAdapter(tenantId);
  }

  /**
   * @method findAll
   * @description 查找所有记录，自动应用租户隔离条件
   * @param {object} [options] 查询选项
   * @returns {Promise<T[]>} 记录列表
   *
   * 查询流程：
   * 1. 构建基础查询语句
   * 2. 根据隔离策略添加租户条件
   * 3. 添加排序和分页条件
   * 4. 执行查询并返回结果
   */
  async findAll(options?: {
    limit?: number;
    offset?: number;
    orderBy?: string;
  }): Promise<T[]> {
    let query = `SELECT * FROM ${this.getTableName()}`;

    // 根据隔离策略添加条件
    query = this.addIsolationConditions(query);

    // 添加排序
    if (options?.orderBy) {
      query += ` ORDER BY ${options.orderBy}`;
    }

    // 添加分页
    if (options?.limit) {
      query += ` LIMIT ${options.limit}`;
      if (options?.offset) {
        query += ` OFFSET ${options.offset}`;
      }
    }

    const result = await this.adapter.query(query);
    return result.rows;
  }

  /**
   * @method findById
   * @description 根据ID查找记录，自动应用租户隔离条件
   * @param {string} id 记录ID
   * @returns {Promise<T | null>} 记录或null
   */
  async findById(id: string): Promise<T | null> {
    let query = `SELECT * FROM ${this.getTableName()} WHERE id = $1`;

    // 根据隔离策略添加条件
    query = this.addIsolationConditions(query);

    const result = await this.adapter.query(query, [id]);
    return result.rows[0] || null;
  }

  /**
   * @method create
   * @description 创建新记录，自动添加租户信息
   * @param {Partial<T>} data 记录数据
   * @returns {Promise<T>} 创建的记录
   *
   * 创建流程：
   * 1. 获取当前租户ID
   * 2. 为表级隔离添加tenant_id字段
   * 3. 构建INSERT语句
   * 4. 执行插入并返回结果
   */
  async create(data: Partial<T>): Promise<T> {
    const tenantId = this.tenantId || this.isolationConfig.getDefaultTenantId();

    // 为表级隔离添加tenant_id
    if (this.isolationConfig.isTableLevel()) {
      const tenantIdField = this.isolationConfig.getTenantIdField();
      (data as any)[tenantIdField] = tenantId;
    }

    const fields = Object.keys(data);
    const values = Object.values(data);
    const placeholders = fields.map((_, index) => `$${index + 1}`).join(', ');

    const query = `
      INSERT INTO ${this.getTableName()} (${fields.join(', ')})
      VALUES (${placeholders})
      RETURNING *
    `;

    const result = await this.adapter.query(query, values);
    return result.rows[0];
  }

  /**
   * @method addIsolationConditions
   * @description 根据隔离策略添加隔离条件
   * @param {string} query 原始查询
   * @returns {string} 修改后的查询
   * @protected
   *
   * 隔离条件添加：
   * 1. 表级隔离：添加WHERE tenant_id = 'tenant-id'条件
   * 2. Schema级隔离：通过适配器处理，不修改查询
   * 3. 数据库级隔离：通过适配器处理，不修改查询
   */
  protected addIsolationConditions(query: string): string {
    if (!this.tenantId) {
      return query;
    }

    const strategy = this.isolationConfig.getStrategy();

    switch (strategy) {
      case IsolationStrategy.TABLE_LEVEL:
        if (this.isolationConfig.shouldAutoAddTenantCondition()) {
          const tenantIdField = this.isolationConfig.getTenantIdField();
          if (!query.toLowerCase().includes('where')) {
            return `${query} WHERE ${tenantIdField} = '${this.tenantId}'`;
          } else {
            return `${query} AND ${tenantIdField} = '${this.tenantId}'`;
          }
        }
        break;

      case IsolationStrategy.SCHEMA_LEVEL:
        // Schema级隔离通过适配器处理，这里不需要修改查询
        break;

      case IsolationStrategy.DATABASE_LEVEL:
        // 数据库级隔离通过适配器处理，这里不需要修改查询
        break;
    }

    return query;
  }

  /**
   * @method getTableName
   * @description 获取表名（子类必须实现）
   * @returns {string} 表名
   * @abstract
   */
  protected abstract getTableName(): string;

  /**
   * @method setTenantId
   * @description 设置租户ID并重新创建适配器
   * @param {string} tenantId 租户ID
   */
  setTenantId(tenantId: string): void {
    (this as any).tenantId = tenantId;
    this.adapter = this.adapterFactory.createAdapter(tenantId);
  }

  /**
   * @method createTenantSpecificRepository
   * @description 创建特定租户的仓储实例
   * @param {string} tenantId 租户ID
   * @returns {TenantAwareRepository<T>} 新的仓储实例
   */
  createTenantSpecificRepository(tenantId: string): TenantAwareRepository<T> {
    const RepositoryClass = this.constructor as new (
      adapterFactory: DatabaseAdapterFactory,
      isolationConfig: IsolationConfigService,
      tenantId?: string,
    ) => TenantAwareRepository<T>;

    return new RepositoryClass(
      this.adapterFactory,
      this.isolationConfig,
      tenantId,
    );
  }
}
````

### 17. 数据库适配器工厂 (Database Adapter Factory) 示例

````typescript
/**
 * @class DatabaseAdapterFactory
 * @description 数据库适配器工厂，负责根据隔离策略动态创建数据库适配器。
 *
 * 工厂职责：
 * 1. 根据隔离策略创建相应的数据库适配器
 * 2. 管理适配器的配置和连接
 * 3. 支持多种隔离策略的动态切换
 * 4. 提供统一的适配器创建接口
 *
 * 隔离策略支持：
 * 1. 数据库级隔离：为每个租户创建独立的数据库连接
 * 2. Schema级隔离：为每个租户创建独立的Schema连接
 * 3. 表级隔离：所有租户共享数据库连接，通过tenant_id隔离
 *
 * 配置管理：
 * 1. 动态读取隔离策略配置
 * 2. 根据策略生成相应的连接配置
 * 3. 支持租户特定的配置覆盖
 * 4. 提供配置验证和错误处理
 *
 * @param {IsolationConfigService} isolationConfig 隔离配置服务
 *
 * @example
 * ```typescript
 * const factory = new DatabaseAdapterFactory(isolationConfig);
 * const adapter = factory.createAdapter('tenant-123');
 * await adapter.connect();
 * ```
 * @since 1.0.0
 */
export class DatabaseAdapterFactory {
  constructor(private readonly isolationConfig: IsolationConfigService) {}

  /**
   * @method createAdapter
   * @description 根据隔离策略创建数据库适配器
   * @param {string} [tenantId] 租户ID，可选
   * @returns {IDatabaseAdapter} 数据库适配器实例
   * @throws {UnsupportedIsolationStrategyError} 当隔离策略不支持时抛出
   *
   * 创建流程：
   * 1. 获取当前隔离策略
   * 2. 根据策略生成连接配置
   * 3. 创建相应的适配器实例
   * 4. 返回配置好的适配器
   */
  createAdapter(tenantId?: string): IDatabaseAdapter {
    const strategy = this.isolationConfig.getStrategy();
    const connectionConfig = this.isolationConfig.getConnectionConfig(tenantId);

    switch (strategy) {
      case IsolationStrategy.DATABASE_LEVEL:
        return this.createDatabaseLevelAdapter(connectionConfig);
      case IsolationStrategy.SCHEMA_LEVEL:
        return this.createSchemaLevelAdapter(connectionConfig);
      case IsolationStrategy.TABLE_LEVEL:
        return this.createTableLevelAdapter(connectionConfig);
      default:
        throw new Error(`Unsupported isolation strategy: ${String(strategy)}`);
    }
  }

  /**
   * @method createDatabaseLevelAdapter
   * @description 创建数据库级隔离适配器
   * @param {object} connectionConfig 连接配置
   * @returns {IDatabaseAdapter} 数据库适配器
   * @private
   *
   * 数据库级隔离特点：
   * 1. 每个租户使用独立的数据库
   * 2. 完全的数据隔离
   * 3. 需要为每个租户创建数据库
   * 4. 连接配置包含租户特定的数据库名
   */
  private createDatabaseLevelAdapter(connectionConfig: {
    database: string;
    tenantId?: string;
  }): IDatabaseAdapter {
    const config: DatabaseConfig = {
      type: 'postgresql',
      host: this.isolationConfig.getHost(),
      port: this.isolationConfig.getPort(),
      username: this.isolationConfig.getUsername(),
      password: this.isolationConfig.getPassword(),
      database: connectionConfig.database,
      pool: this.isolationConfig.getPoolConfig(),
    };

    return new PostgreSQLAdapter(
      config,
      `db-${connectionConfig.tenantId}`,
      this.eventEmitter,
      this.logger,
    );
  }

  /**
   * @method createSchemaLevelAdapter
   * @description 创建Schema级隔离适配器
   * @param {object} connectionConfig 连接配置
   * @returns {IDatabaseAdapter} 数据库适配器
   * @private
   *
   * Schema级隔离特点：
   * 1. 每个租户使用独立的Schema
   * 2. 共享数据库实例
   * 3. 通过Schema名称进行隔离
   * 4. 连接配置包含租户特定的Schema名
   */
  private createSchemaLevelAdapter(connectionConfig: {
    database: string;
    schema?: string;
    tenantId?: string;
  }): IDatabaseAdapter {
    const config: DatabaseConfig = {
      type: 'postgresql',
      host: this.isolationConfig.getHost(),
      port: this.isolationConfig.getPort(),
      username: this.isolationConfig.getUsername(),
      password: this.isolationConfig.getPassword(),
      database: connectionConfig.database,
      schema: connectionConfig.schema,
      pool: this.isolationConfig.getPoolConfig(),
    };

    const adapter = new PostgreSQLAdapter(
      config,
      `schema-${connectionConfig.tenantId}`,
      this.eventEmitter,
      this.logger,
    );

    // 设置默认Schema
    if (connectionConfig.schema) {
      adapter.setDefaultSchema(connectionConfig.schema);
    }

    return adapter;
  }

  /**
   * @method createTableLevelAdapter
   * @description 创建表级隔离适配器
   * @param {object} connectionConfig 连接配置
   * @returns {IDatabaseAdapter} 数据库适配器
   * @private
   *
   * 表级隔离特点：
   * 1. 所有租户共享数据库和Schema
   * 2. 通过tenant_id字段进行隔离
   * 3. 支持行级安全策略
   * 4. 连接配置使用默认数据库
   */
  private createTableLevelAdapter(connectionConfig: {
    database: string;
    tenantId?: string;
  }): IDatabaseAdapter {
    const config: DatabaseConfig = {
      type: 'postgresql',
      host: this.isolationConfig.getHost(),
      port: this.isolationConfig.getPort(),
      username: this.isolationConfig.getUsername(),
      password: this.isolationConfig.getPassword(),
      database: connectionConfig.database,
      pool: this.isolationConfig.getPoolConfig(),
    };

    const adapter = new PostgreSQLAdapter(
      config,
      'table-level',
      this.eventEmitter,
      this.logger,
    );

    // 设置租户上下文
    if (connectionConfig.tenantId) {
      adapter.setTenantContext(connectionConfig.tenantId);
    }

    // 启用行级安全策略
    if (this.isolationConfig.isRowLevelSecurityEnabled()) {
      adapter.enableRowLevelSecurity();
    }

    return adapter;
  }
}
````

### 18. 数据访问对象 (Data Access Object) 示例

````typescript
/**
 * @class UserDao
 * @description
 * 用户数据访问对象，负责用户数据的底层数据库操作和查询优化。
 *
 * DAO职责：
 * 1. 封装复杂的数据库查询逻辑
 * 2. 优化查询性能和索引使用
 * 3. 处理数据库特定的操作
 * 4. 提供批量操作和事务支持
 *
 * 查询优化策略：
 * 1. 使用原生SQL优化复杂查询
 * 2. 实现查询结果分页
 * 3. 使用数据库索引提升性能
 * 4. 避免N+1查询问题
 *
 * 多租户支持：
 * 1. 自动注入租户ID到查询条件
 * 2. 支持租户级的数据统计
 * 3. 实现租户级的数据归档
 * 4. 确保跨租户数据隔离
 *
 * @param {EntityManager} entityManager MikroORM实体管理器
 * @param {ITenantContext} tenantContext 租户上下文
 *
 * @example
 * ```typescript
 * const userDao = new UserDao(entityManager, tenantContext);
 * const users = await userDao.findActiveUsersByOrganization('org-123');
 * const stats = await userDao.getUserStatistics();
 * ```
 * @since 1.0.0
 */
export class UserDao {
  constructor(
    private readonly entityManager: EntityManager,
    private readonly tenantContext: ITenantContext,
  ) {}

  /**
   * @method findActiveUsersByOrganization
   * @description 根据组织ID查找活跃用户，优化查询性能
   * @param {string} organizationId 组织ID
   * @param {number} limit 限制数量
   * @param {number} offset 偏移量
   * @returns {Promise<UserEntity[]>} 用户实体列表
   *
   * 查询优化：
   * 1. 使用复合索引优化查询
   * 2. 只查询必要的字段
   * 3. 使用分页避免大数据量查询
   * 4. 应用租户级数据隔离
   */
  async findActiveUsersByOrganization(
    organizationId: string,
    limit: number = 20,
    offset: number = 0,
  ): Promise<UserEntity[]> {
    const tenantId = this.tenantContext.getCurrentTenantId();

    return await this.entityManager.find(
      UserEntity,
      {
        organizationId,
        tenantId,
        status: UserStatus.ACTIVE,
        deletedAt: null,
      },
      {
        limit,
        offset,
        orderBy: { createdAt: 'DESC' },
        fields: ['id', 'email', 'firstName', 'lastName', 'createdAt'],
      },
    );
  }

  /**
   * @method getUserStatistics
   * @description 获取用户统计信息，使用原生SQL优化性能
   * @returns {Promise<UserStatistics>} 用户统计信息
   *
   * 统计查询：
   * 1. 使用原生SQL聚合查询
   * 2. 一次性获取多个统计指标
   * 3. 应用租户级数据过滤
   * 4. 缓存统计结果
   */
  async getUserStatistics(): Promise<UserStatistics> {
    const tenantId = this.tenantContext.getCurrentTenantId();

    const result = await this.entityManager.execute(
      `
      SELECT 
        COUNT(*) as totalUsers,
        COUNT(CASE WHEN status = 'ACTIVE' THEN 1 END) as activeUsers,
        COUNT(CASE WHEN status = 'PENDING' THEN 1 END) as pendingUsers,
        COUNT(CASE WHEN status = 'DISABLED' THEN 1 END) as disabledUsers,
        COUNT(CASE WHEN created_at >= NOW() - INTERVAL '30 days' THEN 1 END) as newUsersLast30Days
      FROM users 
      WHERE tenant_id = ? AND deleted_at IS NULL
    `,
      [tenantId],
    );

    return {
      totalUsers: result[0].totalUsers,
      activeUsers: result[0].activeUsers,
      pendingUsers: result[0].pendingUsers,
      disabledUsers: result[0].disabledUsers,
      newUsersLast30Days: result[0].newUsersLast30Days,
    };
  }

  /**
   * @method bulkUpdateUserStatus
   * @description 批量更新用户状态，优化批量操作性能
   * @param {string[]} userIds 用户ID列表
   * @param {UserStatus} status 新状态
   * @returns {Promise<number>} 更新的记录数
   *
   * 批量操作优化：
   * 1. 使用批量更新减少数据库往返
   * 2. 在事务中执行确保一致性
   * 3. 应用租户级数据隔离
   * 4. 记录批量操作日志
   */
  async bulkUpdateUserStatus(
    userIds: string[],
    status: UserStatus,
  ): Promise<number> {
    const tenantId = this.tenantContext.getCurrentTenantId();

    return await this.entityManager.transactional(async () => {
      const result = await this.entityManager.nativeUpdate(
        UserEntity,
        {
          id: { $in: userIds },
          tenantId,
          deletedAt: null,
        },
        {
          status,
          updatedAt: new Date(),
        },
      );

      // 记录批量操作日志
      await this.logBulkOperation(
        'bulkUpdateUserStatus',
        userIds.length,
        tenantId,
      );

      return result;
    });
  }
}
````

### 17. 数据库迁移 (Database Migration) 示例

````typescript
/**
 * @class CreateUsersTableMigration
 * @description
 * 创建用户表的数据库迁移，负责用户相关表结构的创建和初始化。
 *
 * 迁移职责：
 * 1. 创建用户相关的数据库表结构
 * 2. 建立必要的索引和约束
 * 3. 设置多租户数据隔离策略
 * 4. 初始化基础数据和配置
 *
 * 表结构设计：
 * 1. 支持多租户数据隔离
 * 2. 实现软删除机制
 * 3. 建立审计日志字段
 * 4. 优化查询性能的索引
 *
 * 数据隔离策略：
 * 1. 基于tenant_id的分区策略
 * 2. 行级安全策略实现
 * 3. 跨租户数据访问控制
 * 4. 数据归档和清理策略
 *
 * @example
 * ```typescript
 * const migration = new CreateUsersTableMigration();
 * await migration.up(); // 执行迁移
 * await migration.down(); // 回滚迁移
 * ```
 * @since 1.0.0
 */
export class CreateUsersTableMigration {
  /**
   * @method up
   * @description 执行数据库迁移，创建用户表结构
   * @returns {Promise<void>}
   * @throws {MigrationError} 当迁移失败时抛出
   *
   * 迁移流程：
   * 1. 创建用户主表
   * 2. 建立必要的索引
   * 3. 设置外键约束
   * 4. 创建触发器
   * 5. 初始化基础数据
   */
  async up(): Promise<void> {
    await this.createUsersTable();
    await this.createIndexes();
    await this.createConstraints();
    await this.createTriggers();
    await this.initializeData();
  }

  /**
   * @method down
   * @description 回滚数据库迁移，删除用户表结构
   * @returns {Promise<void>}
   * @throws {MigrationError} 当回滚失败时抛出
   *
   * 回滚流程：
   * 1. 删除触发器
   * 2. 删除约束
   * 3. 删除索引
   * 4. 删除表结构
   */
  async down(): Promise<void> {
    await this.dropTriggers();
    await this.dropConstraints();
    await this.dropIndexes();
    await this.dropUsersTable();
  }

  /**
   * @method createUsersTable
   * @description 创建用户主表
   * @returns {Promise<void>}
   * @private
   */
  private async createUsersTable(): Promise<void> {
    await this.execute(`
      CREATE TABLE users (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        tenant_id UUID NOT NULL,
        email VARCHAR(255) NOT NULL,
        password_hash VARCHAR(255) NOT NULL,
        first_name VARCHAR(100) NOT NULL,
        last_name VARCHAR(100) NOT NULL,
        status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
        organization_id UUID,
        department_id UUID,
        created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
        deleted_at TIMESTAMP WITH TIME ZONE,
        
        -- 多租户数据隔离约束
        CONSTRAINT fk_users_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id),
        CONSTRAINT fk_users_organization FOREIGN KEY (organization_id) REFERENCES organizations(id),
        CONSTRAINT fk_users_department FOREIGN KEY (department_id) REFERENCES departments(id),
        
        -- 业务约束
        CONSTRAINT chk_user_status CHECK (status IN ('PENDING', 'ACTIVE', 'DISABLED')),
        CONSTRAINT chk_user_email_format CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$')
      )
    `);
  }

  /**
   * @method createIndexes
   * @description 创建性能优化索引
   * @returns {Promise<void>}
   * @private
   */
  private async createIndexes(): Promise<void> {
    // 租户级邮箱唯一性索引
    await this.execute(`
      CREATE UNIQUE INDEX idx_users_tenant_email 
      ON users (tenant_id, email) 
      WHERE deleted_at IS NULL
    `);

    // 组织查询优化索引
    await this.execute(`
      CREATE INDEX idx_users_organization_status 
      ON users (organization_id, status, created_at) 
      WHERE deleted_at IS NULL
    `);

    // 部门查询优化索引
    await this.execute(`
      CREATE INDEX idx_users_department_status 
      ON users (department_id, status, created_at) 
      WHERE deleted_at IS NULL
    `);

    // 软删除查询优化索引
    await this.execute(`
      CREATE INDEX idx_users_tenant_active 
      ON users (tenant_id, status, deleted_at) 
      WHERE deleted_at IS NULL
    `);
  }
}
````

### 18. 缓存服务 (Cache Service) 示例

````typescript
/**
 * @class RedisCacheService
 * @description
 * Redis缓存服务实现，负责提供高性能的数据缓存和会话管理功能。
 *
 * 缓存服务职责：
 * 1. 提供键值对缓存存储
 * 2. 实现缓存过期和淘汰策略
 * 3. 支持分布式缓存同步
 * 4. 提供缓存统计和监控
 *
 * 缓存策略：
 * 1. 基于TTL的自动过期
 * 2. LRU淘汰策略
 * 3. 缓存预热和刷新
 * 4. 缓存穿透和雪崩保护
 *
 * 多租户支持：
 * 1. 基于租户ID的缓存键命名空间
 * 2. 租户级缓存隔离
 * 3. 租户级缓存统计
 * 4. 支持租户级缓存清理
 *
 * @param {Redis} redis Redis客户端实例
 * @param {ITenantContext} tenantContext 租户上下文
 * @param {ICacheConfig} config 缓存配置
 *
 * @example
 * ```typescript
 * const cacheService = new RedisCacheService(redis, tenantContext, config);
 * await cacheService.set('user:123', userData, 300);
 * const userData = await cacheService.get('user:123');
 * ```
 * @since 1.0.0
 */
export class RedisCacheService implements ICacheService {
  constructor(
    private readonly redis: Redis,
    private readonly tenantContext: ITenantContext,
    private readonly config: ICacheConfig,
  ) {}

  /**
   * @method get
   * @description 从缓存中获取数据
   * @param {string} key 缓存键
   * @returns {Promise<T | null>} 缓存数据或null
   * @template T 数据类型
   * @throws {CacheError} 当缓存操作失败时抛出
   *
   * 获取流程：
   * 1. 生成租户级缓存键
   * 2. 从Redis获取数据
   * 3. 反序列化数据
   * 4. 更新缓存统计
   */
  async get<T>(key: string): Promise<T | null> {
    try {
      const tenantKey = this.generateTenantKey(key);
      const cachedData = await this.redis.get(tenantKey);

      if (!cachedData) {
        await this.incrementCacheMiss();
        return null;
      }

      await this.incrementCacheHit();
      return JSON.parse(cachedData) as T;
    } catch (error) {
      throw new CacheError(`Failed to get cache key ${key}: ${error.message}`);
    }
  }

  /**
   * @method set
   * @description 设置缓存数据
   * @param {string} key 缓存键
   * @param {T} value 缓存值
   * @param {number} ttlSeconds TTL秒数
   * @returns {Promise<void>}
   * @template T 数据类型
   * @throws {CacheError} 当缓存操作失败时抛出
   *
   * 设置流程：
   * 1. 生成租户级缓存键
   * 2. 序列化数据
   * 3. 设置Redis缓存
   * 4. 更新缓存统计
   */
  async set<T>(key: string, value: T, ttlSeconds: number): Promise<void> {
    try {
      const tenantKey = this.generateTenantKey(key);
      const serializedData = JSON.stringify(value);

      await this.redis.setex(tenantKey, ttlSeconds, serializedData);
      await this.incrementCacheSet();
    } catch (error) {
      throw new CacheError(`Failed to set cache key ${key}: ${error.message}`);
    }
  }

  /**
   * @method delete
   * @description 删除缓存数据
   * @param {string} key 缓存键
   * @returns {Promise<boolean>} 是否删除成功
   * @throws {CacheError} 当缓存操作失败时抛出
   */
  async delete(key: string): Promise<boolean> {
    try {
      const tenantKey = this.generateTenantKey(key);
      const result = await this.redis.del(tenantKey);
      await this.incrementCacheDelete();
      return result > 0;
    } catch (error) {
      throw new CacheError(
        `Failed to delete cache key ${key}: ${error.message}`,
      );
    }
  }

  /**
   * @method clearTenantCache
   * @description 清理租户级缓存
   * @returns {Promise<number>} 清理的键数量
   * @throws {CacheError} 当缓存操作失败时抛出
   */
  async clearTenantCache(): Promise<number> {
    try {
      const tenantId = this.tenantContext.getCurrentTenantId();
      const pattern = `tenant:${tenantId}:*`;

      const keys = await this.redis.keys(pattern);
      if (keys.length === 0) {
        return 0;
      }

      const result = await this.redis.del(...keys);
      await this.incrementCacheClear(keys.length);
      return result;
    } catch (error) {
      throw new CacheError(`Failed to clear tenant cache: ${error.message}`);
    }
  }

  /**
   * @method generateTenantKey
   * @description 生成租户级缓存键
   * @param {string} key 原始缓存键
   * @returns {string} 租户级缓存键
   * @private
   */
  private generateTenantKey(key: string): string {
    const tenantId = this.tenantContext.getCurrentTenantId();
    return `tenant:${tenantId}:${key}`;
  }
}
````

### 19. 接口层控制器 (Interface Layer Controller) 示例

````typescript
/**
 * @class UserController
 * @description
 * 用户管理控制器，负责处理用户相关的HTTP请求和响应。
 *
 * 控制器职责：
 * 1. 接收和验证HTTP请求
 * 2. 调用应用服务执行业务逻辑
 * 3. 转换数据格式和响应结构
 * 4. 处理异常和错误响应
 *
 * 多租户支持：
 * 1. 自动注入租户上下文
 * 2. 应用数据隔离策略
 * 3. 验证用户权限
 * 4. 支持跨租户操作
 *
 * 请求验证：
 * 1. 使用DTO进行数据验证
 * 2. 应用业务规则验证
 * 3. 处理验证错误
 * 4. 提供详细的错误信息
 *
 * @param {UserApplicationService} userApplicationService 用户应用服务
 * @param {DataIsolationService} dataIsolationService 数据隔离服务
 * @param {PermissionService} permissionService 权限服务
 *
 * @example
 * ```typescript
 * const userController = new UserController(userAppService, dataIsolationService, permissionService);
 * await userController.createUser(createUserDto);
 * ```
 * @since 1.0.0
 */
@Controller('api/users')
@UseGuards(AuthGuard, PermissionGuard)
export class UserController {
  constructor(
    private readonly userApplicationService: UserApplicationService,
    private readonly dataIsolationService: DataIsolationService,
    private readonly permissionService: PermissionService,
  ) {}

  /**
   * @method createUser
   * @description 创建新用户，支持多租户数据隔离
   * @param {CreateUserDto} createUserDto 创建用户数据传输对象
   * @param {Request} request HTTP请求对象
   * @returns {Promise<UserResponseDto>} 创建的用户信息
   * @throws {ValidationError} 当输入数据无效时抛出
   * @throws {InsufficientPermissionError} 当权限不足时抛出
   * @throws {DuplicateEmailError} 当邮箱已存在时抛出
   *
   * 处理流程：
   * 1. 验证请求数据和权限
   * 2. 应用数据隔离策略
   * 3. 调用应用服务创建用户
   * 4. 返回标准化的响应格式
   */
  @Post()
  @RequirePermissions('user:create')
  @UsePipes(ValidationPipe)
  async createUser(
    @Body() createUserDto: CreateUserDto,
    @Request() request: AuthenticatedRequest,
  ): Promise<UserResponseDto> {
    // 1. 验证权限
    await this.validateCreateUserPermission(request.user);

    // 2. 应用数据隔离
    const isolationContext =
      await this.dataIsolationService.getDataIsolationContext(request.user.id);

    // 3. 调用应用服务
    const userId = await this.userApplicationService.createUser(
      createUserDto.email,
      createUserDto.password,
      createUserDto.profile,
      isolationContext.platformId,
      request.user.id,
    );

    // 4. 返回响应
    return {
      id: userId,
      email: createUserDto.email,
      profile: createUserDto.profile,
      status: 'ACTIVE',
      createdAt: new Date(),
    };
  }

  /**
   * @method getUsers
   * @description 获取用户列表，支持多租户数据隔离和分页
   * @param {GetUsersQueryDto} queryDto 查询参数
   * @param {Request} request HTTP请求对象
   * @returns {Promise<PaginatedResponse<UserResponseDto>>} 分页的用户列表
   * @throws {ValidationError} 当查询参数无效时抛出
   * @throws {InsufficientPermissionError} 当权限不足时抛出
   */
  @Get()
  @RequirePermissions('user:read')
  @UsePipes(ValidationPipe)
  async getUsers(
    @Query() queryDto: GetUsersQueryDto,
    @Request() request: AuthenticatedRequest,
  ): Promise<PaginatedResponse<UserResponseDto>> {
    // 1. 验证权限
    await this.validateReadUsersPermission(request.user);

    // 2. 构建查询条件
    const filters: UserFilters = {
      email: queryDto.email,
      status: queryDto.status,
      role: queryDto.role,
    };

    const pagination: PaginationOptions = {
      page: queryDto.page || 1,
      limit: queryDto.limit || 20,
    };

    // 3. 调用应用服务
    const result = await this.userApplicationService.getUsers(
      filters,
      pagination,
      request.user.id,
    );

    // 4. 返回响应
    return {
      data: result.data,
      total: result.total,
      page: result.page,
      limit: result.limit,
      totalPages: result.totalPages,
    };
  }

  /**
   * @method assignUserToTenant
   * @description 分配用户到租户，支持多租户管理
   * @param {string} userId 用户ID
   * @param {AssignUserToTenantDto} assignDto 分配参数
   * @param {Request} request HTTP请求对象
   * @returns {Promise<void>}
   * @throws {UserNotFoundError} 当用户不存在时抛出
   * @throws {TenantNotFoundError} 当租户不存在时抛出
   * @throws {InsufficientPermissionError} 当权限不足时抛出
   */
  @Post(':userId/assign-tenant')
  @RequirePermissions('user:assign:tenant')
  @UsePipes(ValidationPipe)
  async assignUserToTenant(
    @Param('userId') userId: string,
    @Body() assignDto: AssignUserToTenantDto,
    @Request() request: AuthenticatedRequest,
  ): Promise<void> {
    // 1. 验证权限
    await this.validateAssignUserPermission(request.user, assignDto.tenantId);

    // 2. 调用应用服务
    await this.userApplicationService.assignUserToTenant(
      userId,
      assignDto.tenantId,
      request.user.id,
      assignDto.role,
    );
  }

  /**
   * @method validateCreateUserPermission
   * @description 验证创建用户权限
   * @param {User} user 当前用户
   * @returns {Promise<void>}
   * @throws {InsufficientPermissionError} 当权限不足时抛出
   * @private
   */
  private async validateCreateUserPermission(user: User): Promise<void> {
    const hasPermission = await this.permissionService.hasPermission(
      user.id,
      'user:create',
    );

    if (!hasPermission) {
      throw new InsufficientPermissionError('user:create');
    }
  }
}
````

### 20. 数据传输对象 (Data Transfer Object) 示例

````typescript
/**
 * @class CreateUserDto
 * @description
 * 创建用户数据传输对象，封装用户创建请求的数据结构和验证规则。
 *
 * DTO职责：
 * 1. 定义API请求的数据结构
 * 2. 提供数据验证和转换
 * 3. 确保数据格式的一致性
 * 4. 支持API文档生成
 *
 * 验证规则：
 * 1. 邮箱格式验证和唯一性检查
 * 2. 密码强度验证
 * 3. 用户资料完整性验证
 * 4. 业务规则约束验证
 *
 * 多租户支持：
 * 1. 支持租户级数据验证
 * 2. 应用租户级业务规则
 * 3. 确保数据隔离合规性
 * 4. 支持跨租户数据共享
 *
 * @property {string} email 用户邮箱地址，必填且格式验证
 * @property {string} password 用户密码，必填且强度验证
 * @property {UserProfileDto} profile 用户资料信息，必填
 * @property {string} [tenantId] 所属租户ID，可选
 * @property {string} [organizationId] 所属组织ID，可选
 * @property {string} [departmentId] 所属部门ID，可选
 *
 * @example
 * ```typescript
 * const createUserDto = new CreateUserDto();
 * createUserDto.email = 'user@example.com';
 * createUserDto.password = 'SecurePass123!';
 * createUserDto.profile = { firstName: 'John', lastName: 'Doe' };
 * ```
 * @since 1.0.0
 */
export class CreateUserDto {
  @IsEmail({}, { message: '邮箱格式不正确' })
  @ApiProperty({
    description: '用户邮箱地址',
    example: 'user@example.com',
    format: 'email',
  })
  email!: string;

  @IsString()
  @MinLength(8, { message: '密码长度不能少于8位' })
  @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/, {
    message: '密码必须包含大小写字母、数字和特殊字符',
  })
  @ApiProperty({
    description: '用户密码',
    example: 'SecurePass123!',
    minLength: 8,
  })
  password!: string;

  @ValidateNested()
  @Type(() => UserProfileDto)
  @ApiProperty({
    description: '用户资料信息',
    type: UserProfileDto,
  })
  profile!: UserProfileDto;

  @IsOptional()
  @IsUUID(4, { message: '租户ID格式不正确' })
  @ApiProperty({
    description: '所属租户ID',
    example: '123e4567-e89b-12d3-a456-426614174000',
    required: false,
  })
  tenantId?: string;

  @IsOptional()
  @IsUUID(4, { message: '组织ID格式不正确' })
  @ApiProperty({
    description: '所属组织ID',
    example: '123e4567-e89b-12d3-a456-426614174001',
    required: false,
  })
  organizationId?: string;

  @IsOptional()
  @IsUUID(4, { message: '部门ID格式不正确' })
  @ApiProperty({
    description: '所属部门ID',
    example: '123e4567-e89b-12d3-a456-426614174002',
    required: false,
  })
  departmentId?: string;
}

/**
 * @class UserProfileDto
 * @description
 * 用户资料数据传输对象，封装用户个人资料信息。
 *
 * 资料信息包含：
 * 1. 基本信息：姓名、电话、头像
 * 2. 个人设置：语言、时区、主题
 * 3. 通知偏好：邮件、短信、推送
 * 4. 隐私设置：数据共享、可见性
 *
 * @property {string} firstName 用户名字，必填
 * @property {string} lastName 用户姓氏，必填
 * @property {string} [phoneNumber] 电话号码，可选
 * @property {string} [avatar] 头像URL，可选
 * @property {UserPreferencesDto} [preferences] 用户偏好设置，可选
 */
export class UserProfileDto {
  @IsString()
  @MinLength(1, { message: '名字不能为空' })
  @MaxLength(50, { message: '名字长度不能超过50个字符' })
  @ApiProperty({
    description: '用户名字',
    example: 'John',
    minLength: 1,
    maxLength: 50,
  })
  firstName!: string;

  @IsString()
  @MinLength(1, { message: '姓氏不能为空' })
  @MaxLength(50, { message: '姓氏长度不能超过50个字符' })
  @ApiProperty({
    description: '用户姓氏',
    example: 'Doe',
    minLength: 1,
    maxLength: 50,
  })
  lastName!: string;

  @IsOptional()
  @IsPhoneNumber('CN', { message: '电话号码格式不正确' })
  @ApiProperty({
    description: '电话号码',
    example: '+86 138 0013 8000',
    required: false,
  })
  phoneNumber?: string;

  @IsOptional()
  @IsUrl({}, { message: '头像URL格式不正确' })
  @ApiProperty({
    description: '头像URL',
    example: 'https://example.com/avatar.jpg',
    required: false,
  })
  avatar?: string;

  @IsOptional()
  @ValidateNested()
  @Type(() => UserPreferencesDto)
  @ApiProperty({
    description: '用户偏好设置',
    type: UserPreferencesDto,
    required: false,
  })
  preferences?: UserPreferencesDto;
}
````

### 21. 数据隔离服务 (Data Isolation Service) 示例

````typescript
/**
 * @class DataIsolationService
 * @description
 * 数据隔离服务，负责实现多租户数据隔离策略和访问控制。
 *
 * 数据隔离职责：
 * 1. 管理五层数据隔离架构
 * 2. 实现数据访问权限控制
 * 3. 提供数据隔离上下文
 * 4. 支持跨层级数据共享
 *
 * 隔离层级：
 * 1. 平台级：最高权限，可访问所有数据
 * 2. 租户级：租户内数据隔离
 * 3. 组织级：组织内数据隔离
 * 4. 部门级：部门内数据隔离
 * 5. 用户级：个人数据隔离
 *
 * 数据分类：
 * 1. 可共享数据：支持跨层级访问
 * 2. 受保护数据：严格访问控制
 * 3. 敏感数据：加密存储和传输
 * 4. 公开数据：无访问限制
 *
 * @param {UserService} userService 用户服务
 * @param {PermissionService} permissionService 权限服务
 * @param {TenantService} tenantService 租户服务
 *
 * @example
 * ```typescript
 * const isolationService = new DataIsolationService(userService, permissionService, tenantService);
 * const context = await isolationService.getDataIsolationContext('user-123');
 * ```
 * @since 1.0.0
 */
@Injectable()
export class DataIsolationService {
  constructor(
    private readonly userService: UserService,
    private readonly permissionService: PermissionService,
    private readonly tenantService: TenantService,
  ) {}

  /**
   * @method getDataIsolationContext
   * @description 获取用户的数据隔离上下文
   * @param {string} userId 用户ID
   * @returns {Promise<DataIsolationContext>} 数据隔离上下文
   * @throws {UserNotFoundError} 当用户不存在时抛出
   *
   * 上下文包含：
   * 1. 用户身份信息
   * 2. 所属层级信息
   * 3. 权限列表
   * 4. 数据访问范围
   */
  async getDataIsolationContext(userId: string): Promise<DataIsolationContext> {
    // 1. 获取用户信息
    const user = await this.userService.findById(userId);
    if (!user) {
      throw new UserNotFoundError(userId);
    }

    // 2. 获取用户权限
    const permissions = await this.permissionService.getUserPermissions(userId);

    // 3. 确定隔离级别
    const isolationLevel = this.determineIsolationLevel(user);

    // 4. 构建隔离上下文
    return {
      userId: user.id,
      platformId: user.platformId,
      tenantId: user.tenantId,
      organizationId: user.organizationId,
      departmentId: user.departmentId,
      isolationLevel,
      permissions,
      dataAccessScope: this.calculateDataAccessScope(user, permissions),
    };
  }

  /**
   * @method applyDataIsolation
   * @description 应用数据隔离过滤器到查询
   * @param {SelectQueryBuilder<T>} query 查询构建器
   * @param {DataIsolationContext} context 数据隔离上下文
   * @returns {SelectQueryBuilder<T>} 应用隔离后的查询
   * @template T 实体类型
   *
   * 隔离策略：
   * 1. 根据隔离级别添加WHERE条件
   * 2. 应用权限过滤
   * 3. 处理数据共享规则
   * 4. 确保数据安全访问
   */
  applyDataIsolation<T>(
    query: SelectQueryBuilder<T>,
    context: DataIsolationContext,
  ): SelectQueryBuilder<T> {
    switch (context.isolationLevel) {
      case IsolationLevel.PLATFORM:
        // 平台级：可访问所有数据
        return this.applyPlatformLevelIsolation(query, context);

      case IsolationLevel.TENANT:
        // 租户级：只能访问本租户数据
        return this.applyTenantLevelIsolation(query, context);

      case IsolationLevel.ORGANIZATION:
        // 组织级：只能访问本组织数据
        return this.applyOrganizationLevelIsolation(query, context);

      case IsolationLevel.DEPARTMENT:
        // 部门级：只能访问本部门数据
        return this.applyDepartmentLevelIsolation(query, context);

      case IsolationLevel.USER:
        // 用户级：只能访问个人数据
        return this.applyUserLevelIsolation(query, context);

      default:
        throw new UnauthorizedException('Invalid isolation level');
    }
  }

  /**
   * @method checkDataAccess
   * @description 检查数据访问权限
   * @param {string} dataId 数据ID
   * @param {DataIsolationContext} requesterContext 请求者上下文
   * @param {DataAccessLevel} accessLevel 访问级别
   * @returns {Promise<boolean>} 是否有访问权限
   *
   * 权限检查：
   * 1. 验证数据所有权
   * 2. 检查访问权限
   * 3. 应用业务规则
   * 4. 考虑数据共享策略
   */
  async checkDataAccess(
    dataId: string,
    requesterContext: DataIsolationContext,
    accessLevel: DataAccessLevel,
  ): Promise<boolean> {
    // 1. 获取数据分类信息
    const dataClassification = await this.getDataClassification(dataId);

    // 2. 检查数据分类访问权限
    if (dataClassification.classification === DataClassification.PROTECTED) {
      return this.checkProtectedDataAccess(
        dataClassification,
        requesterContext,
        accessLevel,
      );
    }

    // 3. 检查可共享数据访问权限
    if (dataClassification.classification === DataClassification.SHAREABLE) {
      return this.checkShareableDataAccess(
        dataClassification,
        requesterContext,
        accessLevel,
      );
    }

    return false;
  }

  /**
   * @method determineIsolationLevel
   * @description 确定用户的隔离级别
   * @param {User} user 用户对象
   * @returns {IsolationLevel} 隔离级别
   * @private
   */
  private determineIsolationLevel(user: User): IsolationLevel {
    if (user.isPlatformAdmin) {
      return IsolationLevel.PLATFORM;
    }

    if (user.tenantId && user.isTenantAdmin) {
      return IsolationLevel.TENANT;
    }

    if (user.organizationId && user.isOrganizationAdmin) {
      return IsolationLevel.ORGANIZATION;
    }

    if (user.departmentId && user.isDepartmentAdmin) {
      return IsolationLevel.DEPARTMENT;
    }

    return IsolationLevel.USER;
  }

  /**
   * @method applyTenantLevelIsolation
   * @description 应用租户级数据隔离
   * @param {SelectQueryBuilder<T>} query 查询构建器
   * @param {DataIsolationContext} context 数据隔离上下文
   * @returns {SelectQueryBuilder<T>} 应用隔离后的查询
   * @template T 实体类型
   * @private
   */
  private applyTenantLevelIsolation<T>(
    query: SelectQueryBuilder<T>,
    context: DataIsolationContext,
  ): SelectQueryBuilder<T> {
    return query.where('tenantId = :tenantId', {
      tenantId: context.tenantId,
    });
  }
}
````

### 22. 消息队列服务 (Message Queue Service) 示例

````typescript
/**
 * @class MessageQueueService
 * @description
 * 消息队列服务，负责处理异步消息传递和事件分发。
 *
 * 消息队列职责：
 * 1. 发布和消费领域事件
 * 2. 处理异步任务队列
 * 3. 实现消息路由和分发
 * 4. 提供消息持久化和重试机制
 *
 * 消息类型：
 * 1. 领域事件：业务状态变更通知
 * 2. 集成事件：跨边界上下文通信
 * 3. 命令消息：异步命令处理
 * 4. 查询消息：异步查询处理
 *
 * 可靠性保证：
 * 1. 消息持久化存储
 * 2. 消息确认机制
 * 3. 失败重试策略
 * 4. 死信队列处理
 *
 * @param {RedisService} redisService Redis服务
 * @param {Logger} logger 日志服务
 * @param {IMessageSerializer} messageSerializer 消息序列化器
 *
 * @example
 * ```typescript
 * const messageQueue = new MessageQueueService(redisService, logger, messageSerializer);
 * await messageQueue.publishEvent(userCreatedEvent);
 * ```
 * @since 1.0.0
 */
@Injectable()
export class MessageQueueService {
  constructor(
    private readonly redisService: RedisService,
    private readonly logger: Logger,
    private readonly messageSerializer: IMessageSerializer,
  ) {}

  /**
   * @method publishEvent
   * @description 发布领域事件到消息队列
   * @param {IDomainEvent} event 领域事件
   * @returns {Promise<void>}
   * @throws {MessagePublishError} 当消息发布失败时抛出
   *
   * 发布流程：
   * 1. 序列化事件数据
   * 2. 生成消息ID和元数据
   * 3. 发送到消息队列
   * 4. 记录发布日志
   */
  async publishEvent(event: IDomainEvent): Promise<void> {
    try {
      // 1. 序列化事件
      const serializedEvent = this.messageSerializer.serialize(event);

      // 2. 构建消息
      const message: IMessage = {
        id: uuid.v4(),
        type: 'DOMAIN_EVENT',
        eventType: event.eventType,
        aggregateId: event.aggregateId,
        data: serializedEvent,
        metadata: {
          occurredOn: event.occurredOn,
          eventVersion: event.eventVersion,
          tenantId: this.getTenantIdFromEvent(event),
        },
        timestamp: new Date(),
      };

      // 3. 发布到队列
      await this.redisService.lpush('domain_events', JSON.stringify(message));

      // 4. 记录日志
      this.logger.log(
        `Event published: ${event.eventType} for aggregate ${event.aggregateId}`,
      );
    } catch (error) {
      this.logger.error(`Failed to publish event: ${event.eventType}`, error);
      throw new MessagePublishError(
        `Failed to publish event: ${error.message}`,
      );
    }
  }

  /**
   * @method publishCommand
   * @description 发布命令到消息队列
   * @param {ICommand} command 命令对象
   * @returns {Promise<void>}
   * @throws {MessagePublishError} 当消息发布失败时抛出
   */
  async publishCommand(command: ICommand): Promise<void> {
    try {
      const serializedCommand = this.messageSerializer.serialize(command);

      const message: IMessage = {
        id: uuid.v4(),
        type: 'COMMAND',
        commandType: command.constructor.name,
        data: serializedCommand,
        metadata: {
          requestedBy: command.requestedBy,
          tenantId: command.tenantId,
        },
        timestamp: new Date(),
      };

      await this.redisService.lpush('commands', JSON.stringify(message));
      this.logger.log(`Command published: ${command.constructor.name}`);
    } catch (error) {
      this.logger.error(
        `Failed to publish command: ${command.constructor.name}`,
        error,
      );
      throw new MessagePublishError(
        `Failed to publish command: ${error.message}`,
      );
    }
  }

  /**
   * @method consumeEvents
   * @description 消费领域事件
   * @param {IEventHandler} eventHandler 事件处理器
   * @returns {Promise<void>}
   *
   * 消费流程：
   * 1. 从队列获取消息
   * 2. 反序列化事件数据
   * 3. 调用事件处理器
   * 4. 处理消费结果
   */
  async consumeEvents(eventHandler: IEventHandler): Promise<void> {
    while (true) {
      try {
        const messageData = await this.redisService.brpop('domain_events', 5);
        if (!messageData) continue;

        const message: IMessage = JSON.parse(messageData[1]);
        const event = this.messageSerializer.deserialize(message.data);

        // 处理事件
        await eventHandler.handle(event);

        this.logger.log(`Event consumed: ${event.eventType}`);
      } catch (error) {
        this.logger.error('Error consuming event', error);
        // 继续处理下一个消息
      }
    }
  }

  /**
   * @method getTenantIdFromEvent
   * @description 从事件中提取租户ID
   * @param {IDomainEvent} event 领域事件
   * @returns {string | undefined} 租户ID
   * @private
   */
  private getTenantIdFromEvent(event: IDomainEvent): string | undefined {
    // 根据事件类型提取租户ID
    if ('tenantId' in event) {
      return (event as any).tenantId;
    }
    return undefined;
  }
}
````

### 23. 外部服务集成 (External Service Integration) 示例

````typescript
/**
 * @class EmailService
 * @description
 * 邮件服务，负责处理邮件发送和模板管理。
 *
 * 邮件服务职责：
 * 1. 发送各种类型的邮件通知
 * 2. 管理邮件模板和内容
 * 3. 处理邮件发送状态跟踪
 * 4. 支持多租户邮件配置
 *
 * 邮件类型：
 * 1. 欢迎邮件：新用户注册
 * 2. 通知邮件：系统通知
 * 3. 验证邮件：邮箱验证
 * 4. 密码重置邮件：密码重置
 *
 * 多租户支持：
 * 1. 租户级邮件配置
 * 2. 租户级邮件模板
 * 3. 租户级发送限制
 * 4. 租户级邮件统计
 *
 * @param {NodemailerService} nodemailerService Nodemailer服务
 * @param {TemplateService} templateService 模板服务
 * @param {ConfigurationService} configService 配置服务
 * @param {Logger} logger 日志服务
 *
 * @example
 * ```typescript
 * const emailService = new EmailService(nodemailerService, templateService, configService, logger);
 * await emailService.sendWelcomeEmail('user@example.com', 'John');
 * ```
 * @since 1.0.0
 */
@Injectable()
export class EmailService {
  constructor(
    private readonly nodemailerService: NodemailerService,
    private readonly templateService: TemplateService,
    private readonly configService: ConfigurationService,
    private readonly logger: Logger,
  ) {}

  /**
   * @method sendWelcomeEmail
   * @description 发送欢迎邮件给新用户
   * @param {string} email 收件人邮箱
   * @param {string} firstName 用户名字
   * @param {string} [tenantId] 租户ID，可选
   * @returns {Promise<void>}
   * @throws {EmailSendError} 当邮件发送失败时抛出
   *
   * 发送流程：
   * 1. 获取邮件模板
   * 2. 渲染邮件内容
   * 3. 配置邮件参数
   * 4. 发送邮件
   * 5. 记录发送日志
   */
  async sendWelcomeEmail(
    email: string,
    firstName: string,
    tenantId?: string,
  ): Promise<void> {
    try {
      // 1. 获取邮件配置
      const emailConfig = await this.getEmailConfig(tenantId);

      // 2. 获取邮件模板
      const template = await this.templateService.getTemplate(
        'welcome',
        tenantId,
      );

      // 3. 渲染邮件内容
      const html = template.render({
        firstName,
        loginUrl: emailConfig.loginUrl,
        supportEmail: emailConfig.supportEmail,
      });

      // 4. 构建邮件选项
      const mailOptions: SendMailOptions = {
        from: emailConfig.fromAddress,
        to: email,
        subject: `欢迎使用${emailConfig.platformName}`,
        html,
        headers: {
          'X-Tenant-ID': tenantId || 'platform',
        },
      };

      // 5. 发送邮件
      await this.nodemailerService.sendMail(mailOptions);

      // 6. 记录发送日志
      await this.logEmailSent('welcome', email, tenantId);

      this.logger.log(`Welcome email sent to: ${email}`);
    } catch (error) {
      this.logger.error(`Failed to send welcome email to: ${email}`, error);
      throw new EmailSendError(
        `Failed to send welcome email: ${error.message}`,
      );
    }
  }

  /**
   * @method sendNotificationEmail
   * @description 发送通知邮件
   * @param {string} email 收件人邮箱
   * @param {string} subject 邮件主题
   * @param {string} templateName 模板名称
   * @param {any} data 模板数据
   * @param {string} [tenantId] 租户ID，可选
   * @returns {Promise<void>}
   * @throws {EmailSendError} 当邮件发送失败时抛出
   */
  async sendNotificationEmail(
    email: string,
    subject: string,
    templateName: string,
    data: any,
    tenantId?: string,
  ): Promise<void> {
    try {
      const emailConfig = await this.getEmailConfig(tenantId);
      const template = await this.templateService.getTemplate(
        templateName,
        tenantId,
      );
      const html = template.render(data);

      const mailOptions: SendMailOptions = {
        from: emailConfig.fromAddress,
        to: email,
        subject,
        html,
        headers: {
          'X-Tenant-ID': tenantId || 'platform',
          'X-Template': templateName,
        },
      };

      await this.nodemailerService.sendMail(mailOptions);
      await this.logEmailSent('notification', email, tenantId);

      this.logger.log(`Notification email sent to: ${email}`);
    } catch (error) {
      this.logger.error(
        `Failed to send notification email to: ${email}`,
        error,
      );
      throw new EmailSendError(
        `Failed to send notification email: ${error.message}`,
      );
    }
  }

  /**
   * @method getEmailConfig
   * @description 获取邮件配置
   * @param {string} [tenantId] 租户ID，可选
   * @returns {Promise<EmailConfig>} 邮件配置
   * @private
   */
  private async getEmailConfig(tenantId?: string): Promise<EmailConfig> {
    if (tenantId) {
      // 获取租户级配置
      return await this.configService.getTenantEmailConfig(tenantId);
    } else {
      // 获取平台级配置
      return await this.configService.getPlatformEmailConfig();
    }
  }

  /**
   * @method logEmailSent
   * @description 记录邮件发送日志
   * @param {string} emailType 邮件类型
   * @param {string} recipient 收件人
   * @param {string} [tenantId] 租户ID，可选
   * @returns {Promise<void>}
   * @private
   */
  private async logEmailSent(
    emailType: string,
    recipient: string,
    tenantId?: string,
  ): Promise<void> {
    // 记录邮件发送统计
    await this.configService.incrementEmailSentCount(emailType, tenantId);
  }
}
````

### 24. 异步事件处理器 (Async Event Processor) 示例

````typescript
/**
 * @class UserCreatedEventProcessor
 * @description
 * 用户创建事件异步处理器，负责处理用户创建事件的后续业务逻辑。
 *
 * 异步处理职责：
 * 1. 接收并处理用户创建领域事件
 * 2. 更新读模型和视图
 * 3. 触发相关的业务流程
 * 4. 处理事件处理的异常和重试
 *
 * 消息队列集成：
 * 1. 使用Bull队列进行异步事件处理
 * 2. 支持事件重试和指数退避策略
 * 3. 实现死信队列处理失败事件
 * 4. 提供事件处理状态监控
 *
 * 业务流程触发：
 * 1. 发送欢迎邮件
 * 2. 创建用户权限
 * 3. 记录审计日志
 * 4. 更新用户统计
 *
 * @param {Logger} logger 日志服务
 * @param {IUserReadRepository} userReadRepository 用户读模型仓储
 * @param {INotificationService} notificationService 通知服务
 * @param {IPermissionService} permissionService 权限服务
 * @param {IAuditService} auditService 审计服务
 *
 * @example
 * ```typescript
 * const processor = new UserCreatedEventProcessor(
 *   logger, userReadRepo, notificationService, permissionService, auditService
 * );
 * // 通过Bull队列自动处理UserCreatedEvent
 * ```
 * @since 1.0.0
 */
@Processor('domain_events')
export class UserCreatedEventProcessor {
  constructor(
    private readonly logger: Logger,
    private readonly userReadRepository: IUserReadRepository,
    private readonly notificationService: INotificationService,
    private readonly permissionService: IPermissionService,
    private readonly auditService: IAuditService,
  ) {}

  /**
   * @method handleUserCreated
   * @description 处理用户创建事件，执行后续业务逻辑
   * @param {Job<UserCreatedEvent>} job Bull队列任务对象
   * @returns {Promise<void>}
   * @throws {EventProcessingError} 当事件处理失败时抛出
   *
   * 处理流程：
   * 1. 验证事件的有效性
   * 2. 并行更新读模型视图
   * 3. 触发业务流程
   * 4. 记录处理结果
   * 5. 处理重试和错误恢复
   */
  @Process('UserCreatedEvent')
  async handleUserCreated(job: Job<UserCreatedEvent>): Promise<void> {
    const event = job.data;

    try {
      // 1. 验证事件
      this.validateEvent(event);

      // 2. 并行处理多个后续操作
      await Promise.allSettled([
        this.updateUserReadModel(event),
        this.sendWelcomeEmail(event),
        this.logAuditEvent(event),
        this.createUserPermissions(event),
      ]);

      this.logger.log(
        `UserCreatedEvent processed successfully: ${event.aggregateId}`,
      );
    } catch (error) {
      this.logger.error(
        `Failed to process UserCreatedEvent: ${event.aggregateId}`,
        error,
      );
      throw error; // 让Bull重试
    }
  }

  /**
   * @method updateUserReadModel
   * @description 更新用户读模型视图
   * @param {UserCreatedEvent} event 用户创建事件
   * @returns {Promise<void>}
   * @private
   */
  private async updateUserReadModel(event: UserCreatedEvent): Promise<void> {
    const userReadModel: UserReadModel = {
      id: event.aggregateId,
      email: event.email,
      profile: event.profile,
      status: UserStatus.ACTIVE,
      platformId: event.platformId,
      tenantId: null,
      organizationId: null,
      departmentId: null,
      roles: ['PERSONAL_USER'],
      permissions: this.getDefaultPermissions(),
      createdAt: event.occurredOn,
      updatedAt: event.occurredOn,
      version: event.eventVersion,
    };

    await this.userReadRepository.save(userReadModel);
  }

  /**
   * @method sendWelcomeEmail
   * @description 发送欢迎邮件
   * @param {UserCreatedEvent} event 用户创建事件
   * @returns {Promise<void>}
   * @private
   */
  private async sendWelcomeEmail(event: UserCreatedEvent): Promise<void> {
    await this.notificationService.sendWelcomeEmail(
      event.email,
      event.profile.firstName,
    );
  }

  /**
   * @method logAuditEvent
   * @description 记录审计日志
   * @param {UserCreatedEvent} event 用户创建事件
   * @returns {Promise<void>}
   * @private
   */
  private async logAuditEvent(event: UserCreatedEvent): Promise<void> {
    await this.auditService.logEvent({
      eventType: event.eventType,
      aggregateId: event.aggregateId,
      details: event.toJSON(),
      timestamp: event.occurredOn,
    });
  }

  /**
   * @method createUserPermissions
   * @description 创建用户权限
   * @param {UserCreatedEvent} event 用户创建事件
   * @returns {Promise<void>}
   * @private
   */
  private async createUserPermissions(event: UserCreatedEvent): Promise<void> {
    await this.permissionService.createDefaultPermissions(
      event.aggregateId,
      event.platformId,
    );
  }

  /**
   * @method getDefaultPermissions
   * @description 获取默认权限列表
   * @returns {string[]} 默认权限列表
   * @private
   */
  private getDefaultPermissions(): string[] {
    return ['user:read:own', 'user:update:own', 'platform:service:use'];
  }

  /**
   * @method validateEvent
   * @description 验证事件的有效性
   * @param {UserCreatedEvent} event 用户创建事件
   * @returns {void}
   * @throws {ValidationError} 当事件无效时抛出
   * @private
   */
  private validateEvent(event: UserCreatedEvent): void {
    if (!event.aggregateId || !event.email || !event.profile) {
      throw new ValidationError(
        'Invalid UserCreatedEvent: missing required fields',
      );
    }
  }
}
````

### 25. 消息队列服务 (Message Queue Service) 示例

````typescript
/**
 * @class MessageQueueService
 * @description
 * 消息队列服务，负责处理异步消息传递和事件分发。
 *
 * 消息队列职责：
 * 1. 发布和消费领域事件
 * 2. 处理异步任务队列
 * 3. 实现消息路由和分发
 * 4. 提供消息持久化和重试机制
 *
 * 消息类型：
 * 1. 领域事件：业务状态变更通知
 * 2. 集成事件：跨边界上下文通信
 * 3. 命令消息：异步命令处理
 * 4. 查询消息：异步查询处理
 *
 * 可靠性保证：
 * 1. 消息持久化存储
 * 2. 消息确认机制
 * 3. 失败重试策略
 * 4. 死信队列处理
 *
 * @param {RedisService} redisService Redis服务
 * @param {Logger} logger 日志服务
 * @param {IMessageSerializer} messageSerializer 消息序列化器
 *
 * @example
 * ```typescript
 * const messageQueue = new MessageQueueService(redisService, logger, messageSerializer);
 * await messageQueue.publishEvent(userCreatedEvent);
 * ```
 * @since 1.0.0
 */
@Injectable()
export class MessageQueueService {
  constructor(
    private readonly redisService: RedisService,
    private readonly logger: Logger,
    private readonly messageSerializer: IMessageSerializer,
  ) {}

  /**
   * @method publishEvent
   * @description 发布领域事件到消息队列
   * @param {DomainEvent} event 领域事件
   * @returns {Promise<void>}
   * @throws {MessagePublishError} 当消息发布失败时抛出
   *
   * 发布流程：
   * 1. 序列化事件数据
   * 2. 生成消息ID和元数据
   * 3. 发送到消息队列
   * 4. 记录发布日志
   */
  async publishEvent(event: DomainEvent): Promise<void> {
    try {
      // 1. 序列化事件
      const serializedEvent = this.messageSerializer.serialize(event);

      // 2. 构建消息
      const message: IMessage = {
        id: uuid.v4(),
        type: 'DOMAIN_EVENT',
        eventType: event.eventType,
        aggregateId: event.aggregateId,
        data: serializedEvent,
        metadata: {
          occurredOn: event.occurredOn,
          eventVersion: event.eventVersion,
          tenantId: this.getTenantIdFromEvent(event),
        },
        timestamp: new Date(),
      };

      // 3. 发布到队列
      await this.redisService.lpush('domain_events', JSON.stringify(message));

      // 4. 记录日志
      this.logger.log(
        `Event published: ${event.eventType} for aggregate ${event.aggregateId}`,
      );
    } catch (error) {
      this.logger.error(`Failed to publish event: ${event.eventType}`, error);
      throw new MessagePublishError(
        `Failed to publish event: ${error.message}`,
      );
    }
  }

  /**
   * @method publishCommand
   * @description 发布命令到消息队列
   * @param {ICommand} command 命令对象
   * @returns {Promise<void>}
   * @throws {MessagePublishError} 当消息发布失败时抛出
   */
  async publishCommand(command: ICommand): Promise<void> {
    try {
      const serializedCommand = this.messageSerializer.serialize(command);

      const message: IMessage = {
        id: uuid.v4(),
        type: 'COMMAND',
        commandType: command.constructor.name,
        data: serializedCommand,
        metadata: {
          requestedBy: command.requestedBy,
          tenantId: command.tenantId,
        },
        timestamp: new Date(),
      };

      await this.redisService.lpush('commands', JSON.stringify(message));
      this.logger.log(`Command published: ${command.constructor.name}`);
    } catch (error) {
      this.logger.error(
        `Failed to publish command: ${command.constructor.name}`,
        error,
      );
      throw new MessagePublishError(
        `Failed to publish command: ${error.message}`,
      );
    }
  }

  /**
   * @method consumeEvents
   * @description 消费领域事件
   * @param {IEventHandler} eventHandler 事件处理器
   * @returns {Promise<void>}
   *
   * 消费流程：
   * 1. 从队列获取消息
   * 2. 反序列化事件数据
   * 3. 调用事件处理器
   * 4. 处理消费结果
   */
  async consumeEvents(eventHandler: IEventHandler): Promise<void> {
    while (true) {
      try {
        const messageData = await this.redisService.brpop('domain_events', 5);
        if (!messageData) continue;

        const message: IMessage = JSON.parse(messageData[1]);
        const event = this.messageSerializer.deserialize(message.data);

        // 处理事件
        await eventHandler.handle(event);

        this.logger.log(`Event consumed: ${event.eventType}`);
      } catch (error) {
        this.logger.error('Error consuming event', error);
        // 继续处理下一个消息
      }
    }
  }

  /**
   * @method getTenantIdFromEvent
   * @description 从事件中提取租户ID
   * @param {DomainEvent} event 领域事件
   * @returns {string | undefined} 租户ID
   * @private
   */
  private getTenantIdFromEvent(event: DomainEvent): string | undefined {
    // 根据事件类型提取租户ID
    if ('tenantId' in event) {
      return (event as any).tenantId;
    }
    return undefined;
  }
}
````

### 26. 事件总线服务 (Event Bus Service) 示例

````typescript
/**
 * @class EventBusService
 * @description
 * 事件总线服务，负责协调事件存储和消息队列的集成。
 *
 * 事件总线职责：
 * 1. 协调事件存储和消息队列
 * 2. 提供统一的事件发布接口
 * 3. 管理事件的生命周期
 * 4. 处理事件发布的事务性
 *
 * 集成策略：
 * 1. 同步保存到事件存储
 * 2. 异步发布到消息队列
 * 3. 支持事件重放和恢复
 * 4. 提供事件监控和统计
 *
 * 事务管理：
 * 1. 确保事件存储的原子性
 * 2. 支持消息队列的可靠性
 * 3. 处理跨系统的事务协调
 * 4. 提供失败恢复机制
 *
 * @param {IEventStore} eventStore 事件存储服务
 * @param {IMessageQueueService} messageQueueService 消息队列服务
 * @param {Logger} logger 日志服务
 *
 * @example
 * ```typescript
 * const eventBus = new EventBusService(eventStore, messageQueueService, logger);
 * await eventBus.publishAll(events);
 * ```
 * @since 1.0.0
 */
@Injectable()
export class EventBusService {
  constructor(
    private readonly eventStore: IEventStore,
    private readonly messageQueueService: IMessageQueueService,
    private readonly logger: Logger,
  ) {}

  /**
   * @method publishAll
   * @description 发布所有领域事件，协调事件存储和消息队列
   * @param {DomainEvent[]} events 领域事件列表
   * @returns {Promise<void>}
   * @throws {EventPublishError} 当事件发布失败时抛出
   *
   * 发布流程：
   * 1. 验证事件列表的有效性
   * 2. 同步保存到事件存储
   * 3. 异步发布到消息队列
   * 4. 记录发布结果
   */
  async publishAll(events: DomainEvent[]): Promise<void> {
    if (!events || events.length === 0) {
      return;
    }

    try {
      // 1. 验证事件
      this.validateEvents(events);

      // 2. 同步保存到事件存储
      await this.eventStore.saveEvents(events);

      // 3. 异步发布到消息队列
      await Promise.all(
        events.map(event => this.messageQueueService.publishEvent(event)),
      );

      this.logger.log(`Published ${events.length} events successfully`);
    } catch (error) {
      this.logger.error('Failed to publish events', error);
      throw new EventPublishError(`Failed to publish events: ${error.message}`);
    }
  }

  /**
   * @method publishEvent
   * @description 发布单个领域事件
   * @param {DomainEvent} event 领域事件
   * @returns {Promise<void>}
   * @throws {EventPublishError} 当事件发布失败时抛出
   */
  async publishEvent(event: DomainEvent): Promise<void> {
    await this.publishAll([event]);
  }

  /**
   * @method validateEvents
   * @description 验证事件列表的有效性
   * @param {DomainEvent[]} events 领域事件列表
   * @returns {void}
   * @throws {ValidationError} 当事件无效时抛出
   * @private
   */
  private validateEvents(events: DomainEvent[]): void {
    for (const event of events) {
      if (!event.aggregateId || !event.eventType) {
        throw new ValidationError('Invalid event: missing required fields');
      }
    }
  }
}
````

### 27. 配置管理服务 (Configuration Management Service) 示例

````typescript
/**
 * @class ConfigurationService
 * @description
 * 配置管理服务，负责管理多层级配置和动态配置更新。
 *
 * 配置管理职责：
 * 1. 管理平台级、租户级、组织级、部门级配置
 * 2. 支持配置的动态更新和热重载
 * 3. 提供配置版本控制和回滚
 * 4. 实现配置的安全访问控制
 *
 * 配置层级：
 * 1. 平台级：全局配置，影响整个平台
 * 2. 租户级：租户配置，影响租户内所有用户
 * 3. 组织级：组织配置，影响组织内用户
 * 4. 部门级：部门配置，影响部门内用户
 * 5. 用户级：个人配置，仅影响个人
 *
 * 配置类型：
 * 1. 系统配置：系统运行参数
 * 2. 业务配置：业务规则参数
 * 3. 界面配置：用户界面设置
 * 4. 安全配置：安全策略参数
 *
 * @param {IConfigurationRepository} configRepository 配置仓储
 * @param {ICacheService} cacheService 缓存服务
 * @param {IEventBus} eventBus 事件总线
 * @param {Logger} logger 日志服务
 *
 * @example
 * ```typescript
 * const configService = new ConfigurationService(configRepo, cacheService, eventBus, logger);
 * const value = await configService.get('maxUsers', 'tenant-123');
 * ```
 * @since 1.0.0
 */
@Injectable()
export class ConfigurationService {
  constructor(
    private readonly configRepository: IConfigurationRepository,
    private readonly cacheService: ICacheService,
    private readonly eventBus: IEventBus,
    private readonly logger: Logger,
  ) {}

  /**
   * @method get
   * @description 获取配置值，支持多层级配置继承
   * @param {string} key 配置键
   * @param {string} [tenantId] 租户ID，可选
   * @param {string} [organizationId] 组织ID，可选
   * @param {string} [departmentId] 部门ID，可选
   * @param {string} [userId] 用户ID，可选
   * @param {T} [defaultValue] 默认值，可选
   * @returns {Promise<T>} 配置值
   * @template T 配置值类型
   *
   * 配置继承规则：
   * 1. 用户级配置 > 部门级配置 > 组织级配置 > 租户级配置 > 平台级配置
   * 2. 如果上级配置不存在，则使用下级配置
   * 3. 如果所有层级都不存在，则使用默认值
   */
  async get<T>(
    key: string,
    tenantId?: string,
    organizationId?: string,
    departmentId?: string,
    userId?: string,
    defaultValue?: T,
  ): Promise<T> {
    // 1. 生成缓存键
    const cacheKey = this.generateCacheKey(
      key,
      tenantId,
      organizationId,
      departmentId,
      userId,
    );

    // 2. 尝试从缓存获取
    const cachedValue = await this.cacheService.get<T>(cacheKey);
    if (cachedValue !== null) {
      return cachedValue;
    }

    // 3. 按优先级查找配置
    let configValue: T | null = null;

    // 用户级配置
    if (userId && departmentId && organizationId && tenantId) {
      configValue = await this.configRepository.findByKeyAndScope(
        key,
        ConfigurationScope.USER,
        userId,
        departmentId,
        organizationId,
        tenantId,
      );
    }

    // 部门级配置
    if (!configValue && departmentId && organizationId && tenantId) {
      configValue = await this.configRepository.findByKeyAndScope(
        key,
        ConfigurationScope.DEPARTMENT,
        departmentId,
        organizationId,
        tenantId,
      );
    }

    // 组织级配置
    if (!configValue && organizationId && tenantId) {
      configValue = await this.configRepository.findByKeyAndScope(
        key,
        ConfigurationScope.ORGANIZATION,
        organizationId,
        tenantId,
      );
    }

    // 租户级配置
    if (!configValue && tenantId) {
      configValue = await this.configRepository.findByKeyAndScope(
        key,
        ConfigurationScope.TENANT,
        tenantId,
      );
    }

    // 平台级配置
    if (!configValue) {
      configValue = await this.configRepository.findByKeyAndScope(
        key,
        ConfigurationScope.PLATFORM,
      );
    }

    // 4. 使用默认值
    const finalValue = configValue || defaultValue;

    // 5. 缓存结果
    if (finalValue !== null) {
      await this.cacheService.set(cacheKey, finalValue, 300); // 5分钟缓存
    }

    return finalValue;
  }

  /**
   * @method set
   * @description 设置配置值
   * @param {string} key 配置键
   * @param {T} value 配置值
   * @param {ConfigurationScope} scope 配置范围
   * @param {string} [tenantId] 租户ID，可选
   * @param {string} [organizationId] 组织ID，可选
   * @param {string} [departmentId] 部门ID，可选
   * @param {string} [userId] 用户ID，可选
   * @param {string} [updatedBy] 更新者ID，可选
   * @returns {Promise<void>}
   * @template T 配置值类型
   *
   * 设置流程：
   * 1. 验证配置权限
   * 2. 验证配置值格式
   * 3. 保存配置到数据库
   * 4. 清除相关缓存
   * 5. 发布配置变更事件
   */
  async set<T>(
    key: string,
    value: T,
    scope: ConfigurationScope,
    tenantId?: string,
    organizationId?: string,
    departmentId?: string,
    userId?: string,
    updatedBy?: string,
  ): Promise<void> {
    try {
      // 1. 验证配置权限
      await this.validateConfigurationPermission(
        scope,
        tenantId,
        organizationId,
        departmentId,
        userId,
        updatedBy,
      );

      // 2. 验证配置值
      this.validateConfigurationValue(key, value);

      // 3. 保存配置
      const configuration = await this.configRepository.findByKeyAndScope(
        key,
        scope,
        userId,
        departmentId,
        organizationId,
        tenantId,
      );

      if (configuration) {
        // 更新现有配置
        configuration.value = value;
        configuration.updatedAt = new Date();
        configuration.updatedBy = updatedBy;
        await this.configRepository.save(configuration);
      } else {
        // 创建新配置
        const newConfiguration = new Configuration(
          uuid.v4(),
          key,
          value,
          scope,
          tenantId,
          organizationId,
          departmentId,
          userId,
          updatedBy,
        );
        await this.configRepository.save(newConfiguration);
      }

      // 4. 清除缓存
      await this.clearConfigurationCache(
        key,
        tenantId,
        organizationId,
        departmentId,
        userId,
      );

      // 5. 发布配置变更事件
      await this.eventBus.publish(
        new ConfigurationChangedEvent(
          key,
          value,
          scope,
          tenantId,
          organizationId,
          departmentId,
          userId,
          updatedBy,
        ),
      );

      this.logger.log(`Configuration updated: ${key} in scope ${scope}`);
    } catch (error) {
      this.logger.error(`Failed to set configuration: ${key}`, error);
      throw new ConfigurationError(
        `Failed to set configuration: ${error.message}`,
      );
    }
  }

  /**
   * @method generateCacheKey
   * @description 生成配置缓存键
   * @param {string} key 配置键
   * @param {string} [tenantId] 租户ID，可选
   * @param {string} [organizationId] 组织ID，可选
   * @param {string} [departmentId] 部门ID，可选
   * @param {string} [userId] 用户ID，可选
   * @returns {string} 缓存键
   * @private
   */
  private generateCacheKey(
    key: string,
    tenantId?: string,
    organizationId?: string,
    departmentId?: string,
    userId?: string,
  ): string {
    const parts = ['config', key];
    if (tenantId) parts.push('tenant', tenantId);
    if (organizationId) parts.push('org', organizationId);
    if (departmentId) parts.push('dept', departmentId);
    if (userId) parts.push('user', userId);
    return parts.join(':');
  }

  /**
   * @method clearConfigurationCache
   * @description 清除配置缓存
   * @param {string} key 配置键
   * @param {string} [tenantId] 租户ID，可选
   * @param {string} [organizationId] 组织ID，可选
   * @param {string} [departmentId] 部门ID，可选
   * @param {string} [userId] 用户ID，可选
   * @returns {Promise<void>}
   * @private
   */
  private async clearConfigurationCache(
    key: string,
    tenantId?: string,
    organizationId?: string,
    departmentId?: string,
    userId?: string,
  ): Promise<void> {
    // 清除所有相关层级的缓存
    const cacheKeys = [
      this.generateCacheKey(key), // 平台级
    ];

    if (tenantId) {
      cacheKeys.push(this.generateCacheKey(key, tenantId)); // 租户级
    }

    if (organizationId) {
      cacheKeys.push(this.generateCacheKey(key, tenantId, organizationId)); // 组织级
    }

    if (departmentId) {
      cacheKeys.push(
        this.generateCacheKey(key, tenantId, organizationId, departmentId),
      ); // 部门级
    }

    if (userId) {
      cacheKeys.push(
        this.generateCacheKey(
          key,
          tenantId,
          organizationId,
          departmentId,
          userId,
        ),
      ); // 用户级
    }

    // 批量清除缓存
    await Promise.all(
      cacheKeys.map(cacheKey => this.cacheService.delete(cacheKey)),
    );
  }
}
````

## 多租户数据库架构注释规范总结

### 核心原则

1. **多租户数据隔离**: 支持数据库级、Schema级、表级三种隔离策略
2. **配置驱动**: 通过配置动态切换隔离策略，无需修改代码
3. **适配器模式**: 使用统一的数据库适配器接口支持多种数据库
4. **租户感知**: 所有数据操作自动应用租户隔离条件

### 注释要求

- **数据库适配器**: 必须描述多租户支持、连接管理和性能监控
- **租户感知仓储**: 必须描述隔离策略应用、租户上下文管理
- **适配器工厂**: 必须描述策略选择、配置管理和适配器创建
- **隔离配置服务**: 必须描述策略配置、租户管理和配置验证

### 架构优势

- ✅ **灵活隔离**: 支持三种隔离策略，满足不同业务需求
- ✅ **配置驱动**: 通过环境变量动态切换隔离策略
- ✅ **统一接口**: 使用适配器模式提供统一的数据库访问接口
- ✅ **自动隔离**: 仓储层自动应用租户隔离条件，确保数据安全
- ✅ **性能优化**: 支持连接池、查询缓存和性能监控
- ✅ **可扩展**: 支持水平扩展和负载均衡

### 隔离策略对比

| 策略     | 隔离级别 | 性能 | 成本 | 适用场景                 |
| -------- | -------- | ---- | ---- | ------------------------ |
| 数据库级 | 完全隔离 | 高   | 高   | 大型企业，严格合规要求   |
| Schema级 | 中等隔离 | 中   | 中   | 中型企业，平衡性能与隔离 |
| 表级     | 共享隔离 | 低   | 低   | 小型企业，成本敏感场景   |

---

**文档版本**: 2.0  
**最后更新**: 2024-01-01  
**维护者**: 项目开发团队

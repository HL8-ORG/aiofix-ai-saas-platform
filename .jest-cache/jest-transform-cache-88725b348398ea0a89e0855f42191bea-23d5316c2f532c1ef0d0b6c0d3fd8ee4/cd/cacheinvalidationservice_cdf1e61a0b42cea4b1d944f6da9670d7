da41f792e271c7c607ed6907092805c7
"use strict";
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __setFunctionName = (this && this.__setFunctionName) || function (f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheInvalidationService = exports.InvalidationTrigger = exports.InvalidationStrategy = void 0;
const common_1 = require("@nestjs/common");
const uuid_1 = require("uuid");
const logging_1 = require("@aiofix/logging");
/**
 * @enum InvalidationStrategy
 * @description
 * 缓存失效策略枚举，定义不同的失效策略。
 */
var InvalidationStrategy;
(function (InvalidationStrategy) {
    /** 精确匹配 */
    InvalidationStrategy["EXACT"] = "exact";
    /** 前缀匹配 */
    InvalidationStrategy["PREFIX"] = "prefix";
    /** 后缀匹配 */
    InvalidationStrategy["SUFFIX"] = "suffix";
    /** 通配符匹配 */
    InvalidationStrategy["WILDCARD"] = "wildcard";
    /** 正则表达式匹配 */
    InvalidationStrategy["REGEX"] = "regex";
    /** 标签匹配 */
    InvalidationStrategy["TAG"] = "tag";
    /** 命名空间匹配 */
    InvalidationStrategy["NAMESPACE"] = "namespace";
    /** 批量失效 */
    InvalidationStrategy["BATCH"] = "batch";
})(InvalidationStrategy || (exports.InvalidationStrategy = InvalidationStrategy = {}));
/**
 * @enum InvalidationTrigger
 * @description
 * 缓存失效触发器枚举，定义失效的触发方式。
 */
var InvalidationTrigger;
(function (InvalidationTrigger) {
    /** 手动触发 */
    InvalidationTrigger["MANUAL"] = "manual";
    /** 定时触发 */
    InvalidationTrigger["SCHEDULED"] = "scheduled";
    /** 事件触发 */
    InvalidationTrigger["EVENT"] = "event";
    /** 条件触发 */
    InvalidationTrigger["CONDITIONAL"] = "conditional";
    /** 依赖触发 */
    InvalidationTrigger["DEPENDENCY"] = "dependency";
})(InvalidationTrigger || (exports.InvalidationTrigger = InvalidationTrigger = {}));
/**
 * @class CacheInvalidationService
 * @description
 * 缓存失效服务，提供灵活的缓存失效管理功能。
 *
 * 主要功能包括：
 * 1. 支持多种失效策略（精确匹配、通配符、正则表达式等）
 * 2. 支持多种触发方式（手动、定时、事件、条件等）
 * 3. 提供规则管理和优先级控制
 * 4. 支持批量失效和并发处理
 * 5. 提供详细的统计和监控
 * 6. 支持依赖关系和条件表达式
 *
 * @implements {ICacheService}
 */
let CacheInvalidationService = (() => {
    let _classDecorators = [(0, common_1.Injectable)()];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    var CacheInvalidationService = _classThis = class {
        constructor(config, keyFactory, eventEmitter, logger) {
            this.keyFactory = keyFactory;
            this.eventEmitter = eventEmitter;
            /**
             * 失效规则映射
             */
            this.rules = new Map();
            /**
             * 缓存服务实例
             */
            this.cacheService = null;
            this.logger = logger;
            this.config = {
                enabled: true,
                defaultStrategy: InvalidationStrategy.EXACT,
                batchSize: 100,
                concurrency: 5,
                timeout: 30000,
                retries: 3,
                retryDelay: 1000,
                enableStats: true,
                enableEvents: true,
                monitoringInterval: 60000,
                ...config,
            };
            this.stats = this.initializeStats();
            this.startMonitoring();
            this.logger.info('CacheInvalidationService initialized', logging_1.LogContext.CACHE);
        }
        /**
         * @method setCacheService
         * @description 设置缓存服务实例
         * @param cacheService 缓存服务实例
         */
        setCacheService(cacheService) {
            this.cacheService = cacheService;
            this.logger.info('Cache service set for invalidation service', logging_1.LogContext.CACHE);
        }
        /**
         * @method addRule
         * @description 添加失效规则
         * @param rule 失效规则
         * @returns {boolean} 是否成功
         */
        addRule(rule) {
            try {
                const ruleId = rule.id || (0, uuid_1.v4)();
                const now = new Date();
                const fullRule = {
                    ...rule,
                    id: ruleId,
                    createdAt: now,
                    updatedAt: now,
                };
                this.rules.set(ruleId, fullRule);
                this.logger.info(`Added invalidation rule: ${rule.name}`, logging_1.LogContext.CACHE);
                this.emitEvent('rule_added', { rule: fullRule });
                return true;
            }
            catch (error) {
                this.logger.error(`Failed to add invalidation rule: ${rule.name}`, logging_1.LogContext.CACHE, undefined, error);
                return false;
            }
        }
        /**
         * @method removeRule
         * @description 移除失效规则
         * @param ruleId 规则ID
         * @returns {boolean} 是否成功
         */
        removeRule(ruleId) {
            try {
                if (!this.rules.has(ruleId)) {
                    this.logger.warn(`Invalidation rule not found: ${ruleId}`, logging_1.LogContext.CACHE);
                    return false;
                }
                const rule = this.rules.get(ruleId);
                if (!rule) {
                    throw new Error(`Invalidation rule not found: ${ruleId}`);
                }
                this.rules.delete(ruleId);
                this.logger.info(`Removed invalidation rule: ${rule.name}`, logging_1.LogContext.CACHE);
                this.emitEvent('rule_removed', { rule });
                return true;
            }
            catch (error) {
                this.logger.error(`Failed to remove invalidation rule: ${ruleId}`, logging_1.LogContext.CACHE, undefined, error);
                return false;
            }
        }
        /**
         * @method updateRule
         * @description 更新失效规则
         * @param ruleId 规则ID
         * @param updates 更新内容
         * @returns {boolean} 是否成功
         */
        updateRule(ruleId, updates) {
            try {
                if (!this.rules.has(ruleId)) {
                    this.logger.warn(`Invalidation rule not found: ${ruleId}`, logging_1.LogContext.CACHE);
                    return false;
                }
                const existingRule = this.rules.get(ruleId);
                const updatedRule = {
                    ...existingRule,
                    ...updates,
                    updatedAt: new Date(),
                };
                this.rules.set(ruleId, updatedRule);
                this.logger.info(`Updated invalidation rule: ${updatedRule.name}`, logging_1.LogContext.CACHE);
                this.emitEvent('rule_updated', { rule: updatedRule });
                return true;
            }
            catch (error) {
                this.logger.error(`Failed to update invalidation rule: ${ruleId}`, logging_1.LogContext.CACHE, undefined, error);
                return false;
            }
        }
        /**
         * @method getRule
         * @description 获取失效规则
         * @param ruleId 规则ID
         * @returns {InvalidationRule | null} 失效规则
         */
        getRule(ruleId) {
            return this.rules.get(ruleId) || null;
        }
        /**
         * @method getAllRules
         * @description 获取所有失效规则
         * @param enabledOnly 是否只返回启用的规则
         * @returns {InvalidationRule[]} 失效规则列表
         */
        getAllRules(enabledOnly) {
            const rules = Array.from(this.rules.values());
            if (enabledOnly) {
                return rules.filter(rule => rule.enabled);
            }
            return rules;
        }
        /**
         * @method invalidate
         * @description 执行缓存失效
         * @param target 失效目标（键、模式、标签等）
         * @param strategy 失效策略
         * @param options 失效选项
         * @returns {Promise<InvalidationResult>} 失效结果
         */
        async invalidate(target, strategy = this.config.defaultStrategy, options) {
            const startTime = Date.now();
            const targets = Array.isArray(target) ? target : [target];
            try {
                if (!this.cacheService) {
                    throw new Error('Cache service not set');
                }
                const result = {
                    invalidatedKeys: 0,
                    invalidatedNamespaces: 0,
                    invalidatedTags: 0,
                    keys: [],
                    namespaces: [],
                    tags: [],
                    invalidatedAt: new Date(),
                    executionTime: 0,
                    success: false,
                    metadata: options?.metadata || {},
                };
                // 根据策略执行失效
                switch (strategy) {
                    case InvalidationStrategy.EXACT:
                        result.keys = await this.invalidateExact(targets);
                        break;
                    case InvalidationStrategy.PREFIX:
                        result.namespaces = await this.invalidatePrefix(targets);
                        break;
                    case InvalidationStrategy.SUFFIX:
                        result.keys = await this.invalidateSuffix(targets);
                        break;
                    case InvalidationStrategy.WILDCARD:
                        result.keys = await this.invalidateWildcard(targets);
                        break;
                    case InvalidationStrategy.REGEX:
                        result.keys = await this.invalidateRegex(targets);
                        break;
                    case InvalidationStrategy.TAG:
                        result.tags = await this.invalidateTags(targets);
                        break;
                    case InvalidationStrategy.NAMESPACE:
                        result.namespaces = await this.invalidateNamespaces(targets);
                        break;
                    case InvalidationStrategy.BATCH:
                        result.keys = await this.invalidateBatch(targets);
                        break;
                    default:
                        throw new Error(`Unsupported invalidation strategy: ${strategy}`);
                }
                result.invalidatedKeys = result.keys.length;
                result.invalidatedNamespaces = result.namespaces.length;
                result.invalidatedTags = result.tags.length;
                result.executionTime = Date.now() - startTime;
                result.success = true;
                // 更新统计
                this.updateStats(strategy, result.executionTime, result.invalidatedKeys);
                this.logger.info(`Cache invalidation completed: ${result.invalidatedKeys} keys, ${result.executionTime}ms`, logging_1.LogContext.CACHE);
                this.emitEvent('invalidation_completed', { result, strategy });
                return result;
            }
            catch (error) {
                const executionTime = Date.now() - startTime;
                this.updateStats(strategy, executionTime, 0, true);
                this.logger.error(`Cache invalidation failed: ${error.message}`, logging_1.LogContext.CACHE, undefined, error);
                this.emitEvent('invalidation_failed', { error, strategy, targets });
                return {
                    invalidatedKeys: 0,
                    invalidatedNamespaces: 0,
                    invalidatedTags: 0,
                    keys: [],
                    namespaces: [],
                    tags: [],
                    invalidatedAt: new Date(),
                    executionTime,
                    success: false,
                    error: error.message,
                    metadata: options?.metadata || {},
                };
            }
        }
        /**
         * @method invalidateByRule
         * @description 根据规则执行缓存失效
         * @param ruleId 规则ID
         * @param _context 执行上下文
         * @returns {Promise<InvalidationResult>} 失效结果
         */
        async invalidateByRule(ruleId, _context) {
            const rule = this.getRule(ruleId);
            if (!rule) {
                throw new Error(`Invalidation rule not found: ${ruleId}`);
            }
            if (!rule.enabled) {
                this.logger.warn(`Invalidation rule is disabled: ${rule.name}`, logging_1.LogContext.CACHE);
                return {
                    invalidatedKeys: 0,
                    invalidatedNamespaces: 0,
                    invalidatedTags: 0,
                    keys: [],
                    namespaces: [],
                    tags: [],
                    invalidatedAt: new Date(),
                    executionTime: 0,
                    success: false,
                    error: 'Rule is disabled',
                };
            }
            // 检查条件
            if (rule.condition && !this.evaluateCondition(rule.condition, _context)) {
                this.logger.debug(`Invalidation rule condition not met: ${rule.name}`, logging_1.LogContext.CACHE);
                return {
                    invalidatedKeys: 0,
                    invalidatedNamespaces: 0,
                    invalidatedTags: 0,
                    keys: [],
                    namespaces: [],
                    tags: [],
                    invalidatedAt: new Date(),
                    executionTime: 0,
                    success: false,
                    error: 'Condition not met',
                };
            }
            // 检查依赖
            if (rule.dependencies && rule.dependencies.length > 0) {
                for (const depId of rule.dependencies) {
                    const depRule = this.getRule(depId);
                    if (!depRule?.enabled) {
                        this.logger.warn(`Dependency rule not found or disabled: ${depId}`, logging_1.LogContext.CACHE);
                        return {
                            invalidatedKeys: 0,
                            invalidatedNamespaces: 0,
                            invalidatedTags: 0,
                            keys: [],
                            namespaces: [],
                            tags: [],
                            invalidatedAt: new Date(),
                            executionTime: 0,
                            success: false,
                            error: 'Dependency not satisfied',
                        };
                    }
                }
            }
            return this.invalidate(rule.pattern, rule.strategy, {
                metadata: { ruleId, ruleName: rule.name, _context },
            });
        }
        /**
         * @method getStats
         * @description 获取失效统计信息
         * @returns {InvalidationStats} 统计信息
         */
        getStats() {
            return { ...this.stats };
        }
        /**
         * @method resetStats
         * @description 重置失效统计信息
         */
        resetStats() {
            this.stats = this.initializeStats();
            this.logger.info('Invalidation stats reset', logging_1.LogContext.CACHE);
        }
        /**
         * @method onDestroy
         * @description 销毁时清理资源
         */
        onDestroy() {
            this.stopMonitoring();
            this.logger.info('CacheInvalidationService destroyed', logging_1.LogContext.CACHE);
        }
        // 私有方法
        /**
         * @private
         * @method initializeStats
         * @description 初始化统计信息
         * @returns {InvalidationStats} 初始统计信息
         */
        initializeStats() {
            return {
                totalInvalidations: 0,
                successfulInvalidations: 0,
                failedInvalidations: 0,
                averageExecutionTime: 0,
                totalInvalidatedKeys: 0,
                activeRules: 0,
                lastInvalidation: new Date(),
                strategyUsage: Object.values(InvalidationStrategy).reduce((acc, strategy) => {
                    acc[strategy] = 0;
                    return acc;
                }, {}),
                triggerUsage: Object.values(InvalidationTrigger).reduce((acc, trigger) => {
                    acc[trigger] = 0;
                    return acc;
                }, {}),
            };
        }
        /**
         * @private
         * @method invalidateExact
         * @description 精确匹配失效
         * @param keys 缓存键列表
         * @returns {Promise<string[]>} 失效的键列表
         */
        async invalidateExact(keys) {
            const invalidatedKeys = [];
            for (const key of keys) {
                try {
                    // 解析完整的键字符串
                    const cacheKey = this.keyFactory.parse(key);
                    const deleted = await this.cacheService.delete(cacheKey);
                    if (deleted) {
                        invalidatedKeys.push(key);
                    }
                }
                catch (error) {
                    this.logger.warn(`Failed to invalidate exact key: ${key}`, logging_1.LogContext.CACHE, undefined, error);
                }
            }
            return invalidatedKeys;
        }
        /**
         * @private
         * @method invalidatePrefix
         * @description 前缀匹配失效
         * @param prefixes 前缀列表
         * @returns {Promise<string[]>} 失效的键列表
         */
        async invalidatePrefix(prefixes) {
            // 这里需要缓存服务支持前缀查询，简化实现
            const invalidatedKeys = [];
            for (const prefix of prefixes) {
                try {
                    // 假设缓存服务支持按命名空间清除
                    const cleared = await this.cacheService.clear(prefix);
                    if (cleared) {
                        invalidatedKeys.push(prefix);
                    }
                }
                catch (error) {
                    this.logger.warn(`Failed to invalidate prefix: ${prefix}`, logging_1.LogContext.CACHE, undefined, error);
                }
            }
            return invalidatedKeys;
        }
        /**
         * @private
         * @method invalidateSuffix
         * @description 后缀匹配失效
         * @param _suffixes 后缀列表
         * @returns {Promise<string[]>} 失效的键列表
         */
        async invalidateSuffix(_suffixes) {
            // 简化实现，实际需要缓存服务支持后缀查询
            const invalidatedKeys = [];
            // 这里需要遍历所有缓存键来匹配后缀
            // 实际实现中可能需要缓存服务提供键列表查询功能
            return invalidatedKeys;
        }
        /**
         * @private
         * @method invalidateWildcard
         * @description 通配符匹配失效
         * @param patterns 通配符模式列表
         * @returns {Promise<string[]>} 失效的键列表
         */
        async invalidateWildcard(patterns) {
            const invalidatedKeys = [];
            for (const pattern of patterns) {
                try {
                    // 仅记录模式，实际匹配依赖具体缓存实现
                    this.logger.debug(`Wildcard invalidation pattern: ${pattern}`, logging_1.LogContext.CACHE);
                }
                catch (error) {
                    this.logger.warn(`Failed to invalidate wildcard pattern: ${pattern}`, logging_1.LogContext.CACHE, undefined, error);
                }
            }
            return invalidatedKeys;
        }
        /**
         * @private
         * @method invalidateRegex
         * @description 正则表达式匹配失效
         * @param patterns 正则表达式模式列表
         * @returns {Promise<string[]>} 失效的键列表
         */
        async invalidateRegex(patterns) {
            const invalidatedKeys = [];
            for (const pattern of patterns) {
                try {
                    // 仅记录模式，实际匹配依赖具体缓存实现
                    this.logger.debug(`Regex invalidation pattern: ${pattern}`, logging_1.LogContext.CACHE);
                }
                catch (error) {
                    this.logger.warn(`Failed to invalidate regex pattern: ${pattern}`, logging_1.LogContext.CACHE, undefined, error);
                }
            }
            return invalidatedKeys;
        }
        /**
         * @private
         * @method invalidateTags
         * @description 标签匹配失效
         * @param tags 标签列表
         * @returns {Promise<string[]>} 失效的标签列表
         */
        async invalidateTags(tags) {
            // 简化实现，实际需要缓存服务支持标签查询
            const invalidatedTags = [];
            for (const tag of tags) {
                try {
                    // 这里需要缓存服务支持标签失效
                    this.logger.debug(`Tag invalidation: ${tag}`, logging_1.LogContext.CACHE);
                    invalidatedTags.push(tag);
                }
                catch (error) {
                    this.logger.warn(`Failed to invalidate tag: ${tag}`, logging_1.LogContext.CACHE, undefined, error);
                }
            }
            return invalidatedTags;
        }
        /**
         * @private
         * @method invalidateNamespaces
         * @description 命名空间匹配失效
         * @param namespaces 命名空间列表
         * @returns {Promise<string[]>} 失效的命名空间列表
         */
        async invalidateNamespaces(namespaces) {
            const invalidatedNamespaces = [];
            for (const namespace of namespaces) {
                try {
                    const cleared = await this.cacheService.clear(namespace);
                    if (cleared) {
                        invalidatedNamespaces.push(namespace);
                    }
                }
                catch (error) {
                    this.logger.warn(`Failed to invalidate namespace: ${namespace}`, logging_1.LogContext.CACHE, undefined, error);
                }
            }
            return invalidatedNamespaces;
        }
        /**
         * @private
         * @method invalidateBatch
         * @description 批量失效
         * @param targets 目标列表
         * @returns {Promise<string[]>} 失效的键列表
         */
        async invalidateBatch(targets) {
            const invalidatedKeys = [];
            const batchSize = this.config.batchSize || 100;
            // 分批处理
            for (let i = 0; i < targets.length; i += batchSize) {
                const batch = targets.slice(i, i + batchSize);
                try {
                    const batchKeys = await this.invalidateExact(batch);
                    invalidatedKeys.push(...batchKeys);
                }
                catch (error) {
                    this.logger.warn(`Failed to invalidate batch ${i / batchSize + 1}`, logging_1.LogContext.CACHE, undefined, error);
                }
            }
            return invalidatedKeys;
        }
        /**
         * @private
         * @method evaluateCondition
         * @description 评估条件表达式
         * @param condition 条件表达式
         * @param _context 执行上下文
         * @returns {boolean} 条件是否满足
         */
        evaluateCondition(condition, _context) {
            try {
                // 简化实现，实际可以使用表达式引擎
                // 这里只是示例，实际实现需要更复杂的表达式解析
                return true;
            }
            catch (error) {
                this.logger.warn(`Failed to evaluate condition: ${condition}`, logging_1.LogContext.CACHE, undefined, error);
                return false;
            }
        }
        /**
         * @private
         * @method updateStats
         * @description 更新统计信息
         * @param strategy 失效策略
         * @param executionTime 执行时间
         * @param invalidatedKeys 失效键数
         * @param failed 是否失败
         */
        updateStats(strategy, executionTime, invalidatedKeys, failed = false) {
            this.stats.totalInvalidations++;
            if (failed) {
                this.stats.failedInvalidations++;
            }
            else {
                this.stats.successfulInvalidations++;
                this.stats.totalInvalidatedKeys += invalidatedKeys;
            }
            this.stats.averageExecutionTime =
                (this.stats.averageExecutionTime * (this.stats.totalInvalidations - 1) +
                    executionTime) /
                    this.stats.totalInvalidations;
            this.stats.lastInvalidation = new Date();
            this.stats.activeRules = Array.from(this.rules.values()).filter(rule => rule.enabled).length;
            if (this.stats.strategyUsage[strategy] !== undefined) {
                this.stats.strategyUsage[strategy]++;
            }
        }
        /**
         * @private
         * @method emitEvent
         * @description 发送失效事件
         * @param type 事件类型
         * @param _data 事件数据
         */
        emitEvent(type, _data) {
            if (this.config.enableEvents) {
                try {
                    this.eventEmitter.emit(`cache.invalidation.${type}`, {
                        type,
                        data: _data,
                        timestamp: new Date(),
                        serviceId: 'cache-invalidation',
                    });
                }
                catch (error) {
                    this.logger.warn(`Failed to emit invalidation event: ${type}`, logging_1.LogContext.CACHE, undefined, error);
                }
            }
        }
        /**
         * @private
         * @method startMonitoring
         * @description 开始监控
         */
        startMonitoring() {
            if (this.config.monitoringInterval && this.config.monitoringInterval > 0) {
                this.monitoringTimer = setInterval(async () => {
                    try {
                        await this.performMonitoring();
                    }
                    catch (error) {
                        this.logger.error('Invalidation monitoring failed', logging_1.LogContext.CACHE, undefined, error);
                    }
                }, this.config.monitoringInterval);
                this.logger.info(`Started invalidation monitoring, interval: ${this.config.monitoringInterval}ms`, logging_1.LogContext.CACHE);
            }
        }
        /**
         * @private
         * @method stopMonitoring
         * @description 停止监控
         */
        stopMonitoring() {
            if (this.monitoringTimer) {
                clearInterval(this.monitoringTimer);
                this.monitoringTimer = undefined;
                this.logger.info('Stopped invalidation monitoring', logging_1.LogContext.CACHE);
            }
        }
        /**
         * @private
         * @method performMonitoring
         * @description 执行监控
         */
        async performMonitoring() {
            try {
                const stats = this.getStats();
                this.emitEvent('monitoring', { stats });
                // 检查活跃规则
                const activeRules = Array.from(this.rules.values()).filter(rule => rule.enabled);
                this.logger.debug(`Active invalidation rules: ${activeRules.length}`, logging_1.LogContext.CACHE);
            }
            catch (error) {
                this.logger.error('Invalidation monitoring execution failed', logging_1.LogContext.CACHE, undefined, error);
            }
        }
    };
    __setFunctionName(_classThis, "CacheInvalidationService");
    (() => {
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
        __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
        CacheInvalidationService = _classThis = _classDescriptor.value;
        if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        __runInitializers(_classThis, _classExtraInitializers);
    })();
    return CacheInvalidationService = _classThis;
})();
exports.CacheInvalidationService = CacheInvalidationService;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvYXJsaWdsZS9WMS9BaW9maXgvYWlvZml4LWFpLXNhYXMtcGxhdGZvcm0vcGFja2FnZXMvY2FjaGUvc3JjL3NlcnZpY2VzL2NhY2hlLWludmFsaWRhdGlvbi5zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQW9EO0FBRXBELCtCQUFvQztBQUtwQyw2Q0FBZ0U7QUFFaEU7Ozs7R0FJRztBQUNILElBQVksb0JBaUJYO0FBakJELFdBQVksb0JBQW9CO0lBQzlCLFdBQVc7SUFDWCx1Q0FBZSxDQUFBO0lBQ2YsV0FBVztJQUNYLHlDQUFpQixDQUFBO0lBQ2pCLFdBQVc7SUFDWCx5Q0FBaUIsQ0FBQTtJQUNqQixZQUFZO0lBQ1osNkNBQXFCLENBQUE7SUFDckIsY0FBYztJQUNkLHVDQUFlLENBQUE7SUFDZixXQUFXO0lBQ1gsbUNBQVcsQ0FBQTtJQUNYLGFBQWE7SUFDYiwrQ0FBdUIsQ0FBQTtJQUN2QixXQUFXO0lBQ1gsdUNBQWUsQ0FBQTtBQUNqQixDQUFDLEVBakJXLG9CQUFvQixvQ0FBcEIsb0JBQW9CLFFBaUIvQjtBQUVEOzs7O0dBSUc7QUFDSCxJQUFZLG1CQVdYO0FBWEQsV0FBWSxtQkFBbUI7SUFDN0IsV0FBVztJQUNYLHdDQUFpQixDQUFBO0lBQ2pCLFdBQVc7SUFDWCw4Q0FBdUIsQ0FBQTtJQUN2QixXQUFXO0lBQ1gsc0NBQWUsQ0FBQTtJQUNmLFdBQVc7SUFDWCxrREFBMkIsQ0FBQTtJQUMzQixXQUFXO0lBQ1gsZ0RBQXlCLENBQUE7QUFDM0IsQ0FBQyxFQVhXLG1CQUFtQixtQ0FBbkIsbUJBQW1CLFFBVzlCO0FBZ0dEOzs7Ozs7Ozs7Ozs7OztHQWNHO0lBRVUsd0JBQXdCOzRCQURwQyxJQUFBLG1CQUFVLEdBQUU7Ozs7O1FBNkJYLFlBQ3VDLE1BQStCLEVBQ3hDLFVBQTZDLEVBQ3hELFlBQTJCLEVBQzVDLE1BQXlCO1lBRm9CLGVBQVUsR0FBVixVQUFVLENBQWtCO1lBQ3hELGlCQUFZ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SyxLQUFLLENBQUMsaUJBQWlCO1lBQzdCLElBQUksQ0FBQztnQkFDSCxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQzlCLElBQUksQ0FBQyxTQUFTLENBQUMsWUFBWSxFQUFFLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztnQkFFeEMsU0FBUztnQkFDVCxNQUFNLFdBQVcsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQ3hELElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FDckIsQ0FBQztnQkFDRixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FDZiw4QkFBOEIsV0FBVyxDQUFDLE1BQU0sRUFBRSxFQUNsRCxvQkFBVSxDQUFDLEtBQUssQ0FDakIsQ0FBQztZQUNKLENBQUM7WUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO2dCQUNmLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUNmLDBDQUEwQyxFQUMxQyxvQkFBVSxDQUFDLEtBQUssRUFDaEIsU0FBUyxFQUNULEtBQWMsQ0FDZixDQUFDO1lBQ0osQ0FBQztRQUNILENBQUM7Ozs7O1FBbjJCSCw2S0FvMkJDOzs7UUFwMkJZLHVEQUF3Qjs7OztBQUF4Qiw0REFBd0IiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL2hvbWUvYXJsaWdsZS9WMS9BaW9maXgvYWlvZml4LWFpLXNhYXMtcGxhdGZvcm0vcGFja2FnZXMvY2FjaGUvc3JjL3NlcnZpY2VzL2NhY2hlLWludmFsaWRhdGlvbi5zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCB9IGZyb20gJ0BuZXN0anMvY29tbW9uJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlcjIgfSBmcm9tICdAbmVzdGpzL2V2ZW50LWVtaXR0ZXInO1xuaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSAndXVpZCc7XG5cbmltcG9ydCB0eXBlIHsgSUNhY2hlU2VydmljZSB9IGZyb20gJy4uL2ludGVyZmFjZXMvY2FjaGUuaW50ZXJmYWNlJztcbmltcG9ydCB0eXBlIHsgSUNhY2hlS2V5RmFjdG9yeSB9IGZyb20gJy4uL2ludGVyZmFjZXMvY2FjaGUuaW50ZXJmYWNlJztcbmltcG9ydCB0eXBlIHsgSW52YWxpZGF0aW9uUmVzdWx0IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9jYWNoZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgUGlub0xvZ2dlclNlcnZpY2UsIExvZ0NvbnRleHQgfSBmcm9tICdAYWlvZml4L2xvZ2dpbmcnO1xuXG4vKipcbiAqIEBlbnVtIEludmFsaWRhdGlvblN0cmF0ZWd5XG4gKiBAZGVzY3JpcHRpb25cbiAqIOe8k+WtmOWkseaViOetlueVpeaemuS4vu+8jOWumuS5ieS4jeWQjOeahOWkseaViOetlueVpeOAglxuICovXG5leHBvcnQgZW51bSBJbnZhbGlkYXRpb25TdHJhdGVneSB7XG4gIC8qKiDnsr7noa7ljLnphY0gKi9cbiAgRVhBQ1QgPSAnZXhhY3QnLFxuICAvKiog5YmN57yA5Yy56YWNICovXG4gIFBSRUZJWCA9ICdwcmVmaXgnLFxuICAvKiog5ZCO57yA5Yy56YWNICovXG4gIFNVRkZJWCA9ICdzdWZmaXgnLFxuICAvKiog6YCa6YWN56ym5Yy56YWNICovXG4gIFdJTERDQVJEID0gJ3dpbGRjYXJkJyxcbiAgLyoqIOato+WImeihqOi+vuW8j+WMuemFjSAqL1xuICBSRUdFWCA9ICdyZWdleCcsXG4gIC8qKiDmoIfnrb7ljLnphY0gKi9cbiAgVEFHID0gJ3RhZycsXG4gIC8qKiDlkb3lkI3nqbrpl7TljLnphY0gKi9cbiAgTkFNRVNQQUNFID0gJ25hbWVzcGFjZScsXG4gIC8qKiDmibnph4/lpLHmlYggKi9cbiAgQkFUQ0ggPSAnYmF0Y2gnLFxufVxuXG4vKipcbiAqIEBlbnVtIEludmFsaWRhdGlvblRyaWdnZXJcbiAqIEBkZXNjcmlwdGlvblxuICog57yT5a2Y5aSx5pWI6Kem5Y+R5Zmo5p6a5Li+77yM5a6a5LmJ5aSx5pWI55qE6Kem5Y+R5pa55byP44CCXG4gKi9cbmV4cG9ydCBlbnVtIEludmFsaWRhdGlvblRyaWdnZXIge1xuICAvKiog5omL5Yqo6Kem5Y+RICovXG4gIE1BTlVBTCA9ICdtYW51YWwnLFxuICAvKiog5a6a5pe26Kem5Y+RICovXG4gIFNDSEVEVUxFRCA9ICdzY2hlZHVsZWQnLFxuICAvKiog5LqL5Lu26Kem5Y+RICovXG4gIEVWRU5UID0gJ2V2ZW50JyxcbiAgLyoqIOadoeS7tuinpuWPkSAqL1xuICBDT05ESVRJT05BTCA9ICdjb25kaXRpb25hbCcsXG4gIC8qKiDkvp3otZbop6blj5EgKi9cbiAgREVQRU5ERU5DWSA9ICdkZXBlbmRlbmN5Jyxcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIEludmFsaWRhdGlvblJ1bGVcbiAqIEBkZXNjcmlwdGlvblxuICog57yT5a2Y5aSx5pWI6KeE5YiZ5o6l5Y+j77yM5a6a5LmJ5aSx5pWI6KeE5YiZ55qE5L+h5oGv44CCXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW52YWxpZGF0aW9uUnVsZSB7XG4gIC8qKiDop4TliJlJRCAqL1xuICByZWFkb25seSBpZDogc3RyaW5nO1xuICAvKiog6KeE5YiZ5ZCN56ewICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbiAgLyoqIOinhOWImeaPj+i/sCAqL1xuICByZWFkb25seSBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgLyoqIOWkseaViOetlueVpSAqL1xuICByZWFkb25seSBzdHJhdGVneTogSW52YWxpZGF0aW9uU3RyYXRlZ3k7XG4gIC8qKiDljLnphY3mqKHlvI8gKi9cbiAgcmVhZG9ubHkgcGF0dGVybjogc3RyaW5nO1xuICAvKiog6Kem5Y+R5ZmoICovXG4gIHJlYWRvbmx5IHRyaWdnZXI6IEludmFsaWRhdGlvblRyaWdnZXI7XG4gIC8qKiDmmK/lkKblkK/nlKggKi9cbiAgcmVhZG9ubHkgZW5hYmxlZDogYm9vbGVhbjtcbiAgLyoqIOS8mOWFiOe6pyAqL1xuICByZWFkb25seSBwcmlvcml0eTogbnVtYmVyO1xuICAvKiog5p2h5Lu26KGo6L6+5byPICovXG4gIHJlYWRvbmx5IGNvbmRpdGlvbj86IHN0cmluZztcbiAgLyoqIOS+nei1luinhOWImSAqL1xuICByZWFkb25seSBkZXBlbmRlbmNpZXM/OiBzdHJpbmdbXTtcbiAgLyoqIOWumuaXtuihqOi+vuW8jyAqL1xuICByZWFkb25seSBzY2hlZHVsZT86IHN0cmluZztcbiAgLyoqIOS6i+S7tuexu+WeiyAqL1xuICByZWFkb25seSBldmVudFR5cGU/OiBzdHJpbmc7XG4gIC8qKiDmoIfnrb4gKi9cbiAgcmVhZG9ubHkgdGFncz86IHN0cmluZ1tdO1xuICAvKiog5YWD5pWw5o2uICovXG4gIHJlYWRvbmx5IG1ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gIC8qKiDliJvlu7rml7bpl7QgKi9cbiAgcmVhZG9ubHkgY3JlYXRlZEF0OiBEYXRlO1xuICAvKiog5pu05paw5pe26Ze0ICovXG4gIHJlYWRvbmx5IHVwZGF0ZWRBdDogRGF0ZTtcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIEludmFsaWRhdGlvblN0YXRzXG4gKiBAZGVzY3JpcHRpb25cbiAqIOe8k+WtmOWkseaViOe7n+iuoeS/oeaBr+aOpeWPo+OAglxuICovXG5leHBvcnQgaW50ZXJmYWNlIEludmFsaWRhdGlvblN0YXRzIHtcbiAgLyoqIOaAu+WkseaViOasoeaVsCAqL1xuICB0b3RhbEludmFsaWRhdGlvbnM6IG51bWJlcjtcbiAgLyoqIOaIkOWKn+WkseaViOasoeaVsCAqL1xuICBzdWNjZXNzZnVsSW52YWxpZGF0aW9uczogbnVtYmVyO1xuICAvKiog5aSx6LSl5aSx5pWI5qyh5pWwICovXG4gIGZhaWxlZEludmFsaWRhdGlvbnM6IG51bWJlcjtcbiAgLyoqIOW5s+Wdh+aJp+ihjOaXtumXtCAqL1xuICBhdmVyYWdlRXhlY3V0aW9uVGltZTogbnVtYmVyO1xuICAvKiog5oC75aSx5pWI6ZSu5pWwICovXG4gIHRvdGFsSW52YWxpZGF0ZWRLZXlzOiBudW1iZXI7XG4gIC8qKiDmtLvot4Pop4TliJnmlbAgKi9cbiAgYWN0aXZlUnVsZXM6IG51bWJlcjtcbiAgLyoqIOacgOWQjuWkseaViOaXtumXtCAqL1xuICBsYXN0SW52YWxpZGF0aW9uOiBEYXRlO1xuICAvKiog5ZCE562W55Wl5L2/55So57uf6K6hICovXG4gIHN0cmF0ZWd5VXNhZ2U6IFJlY29yZDxJbnZhbGlkYXRpb25TdHJhdGVneSwgbnVtYmVyPjtcbiAgLyoqIOWQhOinpuWPkeWZqOS9v+eUqOe7n+iuoSAqL1xuICB0cmlnZ2VyVXNhZ2U6IFJlY29yZDxJbnZhbGlkYXRpb25UcmlnZ2VyLCBudW1iZXI+O1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgQ2FjaGVJbnZhbGlkYXRpb25Db25maWdcbiAqIEBkZXNjcmlwdGlvblxuICog57yT5a2Y5aSx5pWI5pyN5Yqh6YWN572u5o6l5Y+j44CCXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FjaGVJbnZhbGlkYXRpb25Db25maWcge1xuICAvKiog5piv5ZCm5ZCv55So6Ieq5Yqo5aSx5pWIICovXG4gIGVuYWJsZWQ/OiBib29sZWFuO1xuICAvKiog6buY6K6k5aSx5pWI562W55WlICovXG4gIGRlZmF1bHRTdHJhdGVneT86IEludmFsaWRhdGlvblN0cmF0ZWd5O1xuICAvKiog5om56YeP5aSx5pWI5aSn5bCPICovXG4gIGJhdGNoU2l6ZT86IG51bWJlcjtcbiAgLyoqIOW5tuWPkeWkseaViOaVsCAqL1xuICBjb25jdXJyZW5jeT86IG51bWJlcjtcbiAgLyoqIOi2heaXtuaXtumXtO+8iOavq+enku+8iSAqL1xuICB0aW1lb3V0PzogbnVtYmVyO1xuICAvKiog6YeN6K+V5qyh5pWwICovXG4gIHJldHJpZXM/OiBudW1iZXI7XG4gIC8qKiDph43or5Xlu7bov5/vvIjmr6vnp5LvvIkgKi9cbiAgcmV0cnlEZWxheT86IG51bWJlcjtcbiAgLyoqIOaYr+WQpuWQr+eUqOe7n+iuoSAqL1xuICBlbmFibGVTdGF0cz86IGJvb2xlYW47XG4gIC8qKiDmmK/lkKblkK/nlKjkuovku7YgKi9cbiAgZW5hYmxlRXZlbnRzPzogYm9vbGVhbjtcbiAgLyoqIOebkeaOp+mXtOmalO+8iOavq+enku+8iSAqL1xuICBtb25pdG9yaW5nSW50ZXJ2YWw/OiBudW1iZXI7XG59XG5cbi8qKlxuICogQGNsYXNzIENhY2hlSW52YWxpZGF0aW9uU2VydmljZVxuICogQGRlc2NyaXB0aW9uXG4gKiDnvJPlrZjlpLHmlYjmnI3liqHvvIzmj5DkvpvngbXmtLvnmoTnvJPlrZjlpLHmlYjnrqHnkIblip/og73jgIJcbiAqXG4gKiDkuLvopoHlip/og73ljIXmi6zvvJpcbiAqIDEuIOaUr+aMgeWkmuenjeWkseaViOetlueVpe+8iOeyvuehruWMuemFjeOAgemAmumFjeespuOAgeato+WImeihqOi+vuW8j+etie+8iVxuICogMi4g5pSv5oyB5aSa56eN6Kem5Y+R5pa55byP77yI5omL5Yqo44CB5a6a5pe244CB5LqL5Lu244CB5p2h5Lu2562J77yJXG4gKiAzLiDmj5Dkvpvop4TliJnnrqHnkIblkozkvJjlhYjnuqfmjqfliLZcbiAqIDQuIOaUr+aMgeaJuemHj+WkseaViOWSjOW5tuWPkeWkhOeQhlxuICogNS4g5o+Q5L6b6K+m57uG55qE57uf6K6h5ZKM55uR5o6nXG4gKiA2LiDmlK/mjIHkvp3otZblhbPns7vlkozmnaHku7booajovr7lvI9cbiAqXG4gKiBAaW1wbGVtZW50cyB7SUNhY2hlU2VydmljZX1cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIENhY2hlSW52YWxpZGF0aW9uU2VydmljZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgbG9nZ2VyOiBQaW5vTG9nZ2VyU2VydmljZTtcblxuICAvKipcbiAgICog5aSx5pWI6KeE5YiZ5pig5bCEXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IHJ1bGVzID0gbmV3IE1hcDxzdHJpbmcsIEludmFsaWRhdGlvblJ1bGU+KCk7XG5cbiAgLyoqXG4gICAqIOe8k+WtmOacjeWKoeWunuS+i1xuICAgKi9cbiAgcHJpdmF0ZSBjYWNoZVNlcnZpY2U6IElDYWNoZVNlcnZpY2UgfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICog5pyN5Yqh6YWN572uXG4gICAqL1xuICBwcml2YXRlIGNvbmZpZzogQ2FjaGVJbnZhbGlkYXRpb25Db25maWc7XG5cbiAgLyoqXG4gICAqIOe7n+iuoeS/oeaBr1xuICAgKi9cbiAgcHJpdmF0ZSBzdGF0czogSW52YWxpZGF0aW9uU3RhdHM7XG5cbiAgLyoqXG4gICAqIOebkeaOp+WumuaXtuWZqFxuICAgKi9cbiAgcHJpdmF0ZSBtb25pdG9yaW5nVGltZXI/OiBOb2RlSlMuVGltZW91dDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KCdDQUNIRV9JTlZBTElEQVRJT05fQ09ORklHJykgY29uZmlnOiBDYWNoZUludmFsaWRhdGlvbkNvbmZpZyxcbiAgICBASW5qZWN0KCdJQ2FjaGVLZXlGYWN0b3J5JykgcHJpdmF0ZSByZWFkb25seSBrZXlGYWN0b3J5OiBJQ2FjaGVLZXlGYWN0b3J5LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZXZlbnRFbWl0dGVyOiBFdmVudEVtaXR0ZXIyLFxuICAgIGxvZ2dlcjogUGlub0xvZ2dlclNlcnZpY2UsXG4gICkge1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIGRlZmF1bHRTdHJhdGVneTogSW52YWxpZGF0aW9uU3RyYXRlZ3kuRVhBQ1QsXG4gICAgICBiYXRjaFNpemU6IDEwMCxcbiAgICAgIGNvbmN1cnJlbmN5OiA1LFxuICAgICAgdGltZW91dDogMzAwMDAsXG4gICAgICByZXRyaWVzOiAzLFxuICAgICAgcmV0cnlEZWxheTogMTAwMCxcbiAgICAgIGVuYWJsZVN0YXRzOiB0cnVlLFxuICAgICAgZW5hYmxlRXZlbnRzOiB0cnVlLFxuICAgICAgbW9uaXRvcmluZ0ludGVydmFsOiA2MDAwMCxcbiAgICAgIC4uLmNvbmZpZyxcbiAgICB9O1xuXG4gICAgdGhpcy5zdGF0cyA9IHRoaXMuaW5pdGlhbGl6ZVN0YXRzKCk7XG4gICAgdGhpcy5zdGFydE1vbml0b3JpbmcoKTtcblxuICAgIHRoaXMubG9nZ2VyLmluZm8oJ0NhY2hlSW52YWxpZGF0aW9uU2VydmljZSBpbml0aWFsaXplZCcsIExvZ0NvbnRleHQuQ0FDSEUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2V0Q2FjaGVTZXJ2aWNlXG4gICAqIEBkZXNjcmlwdGlvbiDorr7nva7nvJPlrZjmnI3liqHlrp7kvotcbiAgICogQHBhcmFtIGNhY2hlU2VydmljZSDnvJPlrZjmnI3liqHlrp7kvotcbiAgICovXG4gIHNldENhY2hlU2VydmljZShjYWNoZVNlcnZpY2U6IElDYWNoZVNlcnZpY2UpOiB2b2lkIHtcbiAgICB0aGlzLmNhY2hlU2VydmljZSA9IGNhY2hlU2VydmljZTtcbiAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgJ0NhY2hlIHNlcnZpY2Ugc2V0IGZvciBpbnZhbGlkYXRpb24gc2VydmljZScsXG4gICAgICBMb2dDb250ZXh0LkNBQ0hFLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBhZGRSdWxlXG4gICAqIEBkZXNjcmlwdGlvbiDmt7vliqDlpLHmlYjop4TliJlcbiAgICogQHBhcmFtIHJ1bGUg5aSx5pWI6KeE5YiZXG4gICAqIEByZXR1cm5zIHtib29sZWFufSDmmK/lkKbmiJDlip9cbiAgICovXG4gIGFkZFJ1bGUoXG4gICAgcnVsZTogT21pdDxJbnZhbGlkYXRpb25SdWxlLCAnaWQnIHwgJ2NyZWF0ZWRBdCcgfCAndXBkYXRlZEF0Jz4gJiB7XG4gICAgICBpZD86IHN0cmluZztcbiAgICB9LFxuICApOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcnVsZUlkID0gcnVsZS5pZCB8fCB1dWlkdjQoKTtcbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG5cbiAgICAgIGNvbnN0IGZ1bGxSdWxlOiBJbnZhbGlkYXRpb25SdWxlID0ge1xuICAgICAgICAuLi5ydWxlLFxuICAgICAgICBpZDogcnVsZUlkLFxuICAgICAgICBjcmVhdGVkQXQ6IG5vdyxcbiAgICAgICAgdXBkYXRlZEF0OiBub3csXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnJ1bGVzLnNldChydWxlSWQsIGZ1bGxSdWxlKTtcblxuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcbiAgICAgICAgYEFkZGVkIGludmFsaWRhdGlvbiBydWxlOiAke3J1bGUubmFtZX1gLFxuICAgICAgICBMb2dDb250ZXh0LkNBQ0hFLFxuICAgICAgKTtcbiAgICAgIHRoaXMuZW1pdEV2ZW50KCdydWxlX2FkZGVkJywgeyBydWxlOiBmdWxsUnVsZSB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBhZGQgaW52YWxpZGF0aW9uIHJ1bGU6ICR7cnVsZS5uYW1lfWAsXG4gICAgICAgIExvZ0NvbnRleHQuQ0FDSEUsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgZXJyb3IgYXMgRXJyb3IsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlbW92ZVJ1bGVcbiAgICogQGRlc2NyaXB0aW9uIOenu+mZpOWkseaViOinhOWImVxuICAgKiBAcGFyYW0gcnVsZUlkIOinhOWImUlEXG4gICAqIEByZXR1cm5zIHtib29sZWFufSDmmK/lkKbmiJDlip9cbiAgICovXG4gIHJlbW92ZVJ1bGUocnVsZUlkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLnJ1bGVzLmhhcyhydWxlSWQpKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXG4gICAgICAgICAgYEludmFsaWRhdGlvbiBydWxlIG5vdCBmb3VuZDogJHtydWxlSWR9YCxcbiAgICAgICAgICBMb2dDb250ZXh0LkNBQ0hFLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJ1bGUgPSB0aGlzLnJ1bGVzLmdldChydWxlSWQpO1xuICAgICAgaWYgKCFydWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZGF0aW9uIHJ1bGUgbm90IGZvdW5kOiAke3J1bGVJZH1gKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucnVsZXMuZGVsZXRlKHJ1bGVJZCk7XG5cbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oXG4gICAgICAgIGBSZW1vdmVkIGludmFsaWRhdGlvbiBydWxlOiAke3J1bGUubmFtZX1gLFxuICAgICAgICBMb2dDb250ZXh0LkNBQ0hFLFxuICAgICAgKTtcbiAgICAgIHRoaXMuZW1pdEV2ZW50KCdydWxlX3JlbW92ZWQnLCB7IHJ1bGUgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gcmVtb3ZlIGludmFsaWRhdGlvbiBydWxlOiAke3J1bGVJZH1gLFxuICAgICAgICBMb2dDb250ZXh0LkNBQ0hFLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIGVycm9yIGFzIEVycm9yLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB1cGRhdGVSdWxlXG4gICAqIEBkZXNjcmlwdGlvbiDmm7TmlrDlpLHmlYjop4TliJlcbiAgICogQHBhcmFtIHJ1bGVJZCDop4TliJlJRFxuICAgKiBAcGFyYW0gdXBkYXRlcyDmm7TmlrDlhoXlrrlcbiAgICogQHJldHVybnMge2Jvb2xlYW59IOaYr+WQpuaIkOWKn1xuICAgKi9cbiAgdXBkYXRlUnVsZShcbiAgICBydWxlSWQ6IHN0cmluZyxcbiAgICB1cGRhdGVzOiBQYXJ0aWFsPE9taXQ8SW52YWxpZGF0aW9uUnVsZSwgJ2lkJyB8ICdjcmVhdGVkQXQnPj4sXG4gICk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMucnVsZXMuaGFzKHJ1bGVJZCkpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgICAgICBgSW52YWxpZGF0aW9uIHJ1bGUgbm90IGZvdW5kOiAke3J1bGVJZH1gLFxuICAgICAgICAgIExvZ0NvbnRleHQuQ0FDSEUsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXhpc3RpbmdSdWxlID0gdGhpcy5ydWxlcy5nZXQocnVsZUlkKSE7XG4gICAgICBjb25zdCB1cGRhdGVkUnVsZTogSW52YWxpZGF0aW9uUnVsZSA9IHtcbiAgICAgICAgLi4uZXhpc3RpbmdSdWxlLFxuICAgICAgICAuLi51cGRhdGVzLFxuICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnJ1bGVzLnNldChydWxlSWQsIHVwZGF0ZWRSdWxlKTtcblxuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcbiAgICAgICAgYFVwZGF0ZWQgaW52YWxpZGF0aW9uIHJ1bGU6ICR7dXBkYXRlZFJ1bGUubmFtZX1gLFxuICAgICAgICBMb2dDb250ZXh0LkNBQ0hFLFxuICAgICAgKTtcbiAgICAgIHRoaXMuZW1pdEV2ZW50KCdydWxlX3VwZGF0ZWQnLCB7IHJ1bGU6IHVwZGF0ZWRSdWxlIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIHVwZGF0ZSBpbnZhbGlkYXRpb24gcnVsZTogJHtydWxlSWR9YCxcbiAgICAgICAgTG9nQ29udGV4dC5DQUNIRSxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBlcnJvciBhcyBFcnJvcixcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZ2V0UnVsZVxuICAgKiBAZGVzY3JpcHRpb24g6I635Y+W5aSx5pWI6KeE5YiZXG4gICAqIEBwYXJhbSBydWxlSWQg6KeE5YiZSURcbiAgICogQHJldHVybnMge0ludmFsaWRhdGlvblJ1bGUgfCBudWxsfSDlpLHmlYjop4TliJlcbiAgICovXG4gIGdldFJ1bGUocnVsZUlkOiBzdHJpbmcpOiBJbnZhbGlkYXRpb25SdWxlIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMuZ2V0KHJ1bGVJZCkgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGdldEFsbFJ1bGVzXG4gICAqIEBkZXNjcmlwdGlvbiDojrflj5bmiYDmnInlpLHmlYjop4TliJlcbiAgICogQHBhcmFtIGVuYWJsZWRPbmx5IOaYr+WQpuWPqui/lOWbnuWQr+eUqOeahOinhOWImVxuICAgKiBAcmV0dXJucyB7SW52YWxpZGF0aW9uUnVsZVtdfSDlpLHmlYjop4TliJnliJfooahcbiAgICovXG4gIGdldEFsbFJ1bGVzKGVuYWJsZWRPbmx5PzogYm9vbGVhbik6IEludmFsaWRhdGlvblJ1bGVbXSB7XG4gICAgY29uc3QgcnVsZXMgPSBBcnJheS5mcm9tKHRoaXMucnVsZXMudmFsdWVzKCkpO1xuXG4gICAgaWYgKGVuYWJsZWRPbmx5KSB7XG4gICAgICByZXR1cm4gcnVsZXMuZmlsdGVyKHJ1bGUgPT4gcnVsZS5lbmFibGVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnVsZXM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpbnZhbGlkYXRlXG4gICAqIEBkZXNjcmlwdGlvbiDmiafooYznvJPlrZjlpLHmlYhcbiAgICogQHBhcmFtIHRhcmdldCDlpLHmlYjnm67moIfvvIjplK7jgIHmqKHlvI/jgIHmoIfnrb7nrYnvvIlcbiAgICogQHBhcmFtIHN0cmF0ZWd5IOWkseaViOetlueVpVxuICAgKiBAcGFyYW0gb3B0aW9ucyDlpLHmlYjpgInpoblcbiAgICogQHJldHVybnMge1Byb21pc2U8SW52YWxpZGF0aW9uUmVzdWx0Pn0g5aSx5pWI57uT5p6cXG4gICAqL1xuICBhc3luYyBpbnZhbGlkYXRlKFxuICAgIHRhcmdldDogc3RyaW5nIHwgc3RyaW5nW10sXG4gICAgc3RyYXRlZ3k6IEludmFsaWRhdGlvblN0cmF0ZWd5ID0gdGhpcy5jb25maWcuZGVmYXVsdFN0cmF0ZWd5ISxcbiAgICBvcHRpb25zPzoge1xuICAgICAgbmFtZXNwYWNlPzogc3RyaW5nO1xuICAgICAgdGFncz86IHN0cmluZ1tdO1xuICAgICAgdGltZW91dD86IG51bWJlcjtcbiAgICAgIHJldHJpZXM/OiBudW1iZXI7XG4gICAgICBtZXRhZGF0YT86IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgIH0sXG4gICk6IFByb21pc2U8SW52YWxpZGF0aW9uUmVzdWx0PiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCB0YXJnZXRzID0gQXJyYXkuaXNBcnJheSh0YXJnZXQpID8gdGFyZ2V0IDogW3RhcmdldF07XG5cbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLmNhY2hlU2VydmljZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhY2hlIHNlcnZpY2Ugbm90IHNldCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQ6IEludmFsaWRhdGlvblJlc3VsdCA9IHtcbiAgICAgICAgaW52YWxpZGF0ZWRLZXlzOiAwLFxuICAgICAgICBpbnZhbGlkYXRlZE5hbWVzcGFjZXM6IDAsXG4gICAgICAgIGludmFsaWRhdGVkVGFnczogMCxcbiAgICAgICAga2V5czogW10sXG4gICAgICAgIG5hbWVzcGFjZXM6IFtdLFxuICAgICAgICB0YWdzOiBbXSxcbiAgICAgICAgaW52YWxpZGF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgZXhlY3V0aW9uVGltZTogMCxcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIG1ldGFkYXRhOiBvcHRpb25zPy5tZXRhZGF0YSB8fCB7fSxcbiAgICAgIH07XG5cbiAgICAgIC8vIOagueaNruetlueVpeaJp+ihjOWkseaViFxuICAgICAgc3dpdGNoIChzdHJhdGVneSkge1xuICAgICAgICBjYXNlIEludmFsaWRhdGlvblN0cmF0ZWd5LkVYQUNUOlxuICAgICAgICAgIHJlc3VsdC5rZXlzID0gYXdhaXQgdGhpcy5pbnZhbGlkYXRlRXhhY3QodGFyZ2V0cyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSW52YWxpZGF0aW9uU3RyYXRlZ3kuUFJFRklYOlxuICAgICAgICAgIHJlc3VsdC5uYW1lc3BhY2VzID0gYXdhaXQgdGhpcy5pbnZhbGlkYXRlUHJlZml4KHRhcmdldHMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEludmFsaWRhdGlvblN0cmF0ZWd5LlNVRkZJWDpcbiAgICAgICAgICByZXN1bHQua2V5cyA9IGF3YWl0IHRoaXMuaW52YWxpZGF0ZVN1ZmZpeCh0YXJnZXRzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBJbnZhbGlkYXRpb25TdHJhdGVneS5XSUxEQ0FSRDpcbiAgICAgICAgICByZXN1bHQua2V5cyA9IGF3YWl0IHRoaXMuaW52YWxpZGF0ZVdpbGRjYXJkKHRhcmdldHMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEludmFsaWRhdGlvblN0cmF0ZWd5LlJFR0VYOlxuICAgICAgICAgIHJlc3VsdC5rZXlzID0gYXdhaXQgdGhpcy5pbnZhbGlkYXRlUmVnZXgodGFyZ2V0cyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSW52YWxpZGF0aW9uU3RyYXRlZ3kuVEFHOlxuICAgICAgICAgIHJlc3VsdC50YWdzID0gYXdhaXQgdGhpcy5pbnZhbGlkYXRlVGFncyh0YXJnZXRzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBJbnZhbGlkYXRpb25TdHJhdGVneS5OQU1FU1BBQ0U6XG4gICAgICAgICAgcmVzdWx0Lm5hbWVzcGFjZXMgPSBhd2FpdCB0aGlzLmludmFsaWRhdGVOYW1lc3BhY2VzKHRhcmdldHMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEludmFsaWRhdGlvblN0cmF0ZWd5LkJBVENIOlxuICAgICAgICAgIHJlc3VsdC5rZXlzID0gYXdhaXQgdGhpcy5pbnZhbGlkYXRlQmF0Y2godGFyZ2V0cyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBpbnZhbGlkYXRpb24gc3RyYXRlZ3k6ICR7c3RyYXRlZ3l9YCk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5pbnZhbGlkYXRlZEtleXMgPSByZXN1bHQua2V5cy5sZW5ndGg7XG4gICAgICByZXN1bHQuaW52YWxpZGF0ZWROYW1lc3BhY2VzID0gcmVzdWx0Lm5hbWVzcGFjZXMubGVuZ3RoO1xuICAgICAgcmVzdWx0LmludmFsaWRhdGVkVGFncyA9IHJlc3VsdC50YWdzLmxlbmd0aDtcbiAgICAgIHJlc3VsdC5leGVjdXRpb25UaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIHJlc3VsdC5zdWNjZXNzID0gdHJ1ZTtcblxuICAgICAgLy8g5pu05paw57uf6K6hXG4gICAgICB0aGlzLnVwZGF0ZVN0YXRzKHN0cmF0ZWd5LCByZXN1bHQuZXhlY3V0aW9uVGltZSwgcmVzdWx0LmludmFsaWRhdGVkS2V5cyk7XG5cbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oXG4gICAgICAgIGBDYWNoZSBpbnZhbGlkYXRpb24gY29tcGxldGVkOiAke3Jlc3VsdC5pbnZhbGlkYXRlZEtleXN9IGtleXMsICR7cmVzdWx0LmV4ZWN1dGlvblRpbWV9bXNgLFxuICAgICAgICBMb2dDb250ZXh0LkNBQ0hFLFxuICAgICAgKTtcbiAgICAgIHRoaXMuZW1pdEV2ZW50KCdpbnZhbGlkYXRpb25fY29tcGxldGVkJywgeyByZXN1bHQsIHN0cmF0ZWd5IH0pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBleGVjdXRpb25UaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIHRoaXMudXBkYXRlU3RhdHMoc3RyYXRlZ3ksIGV4ZWN1dGlvblRpbWUsIDAsIHRydWUpO1xuXG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgYENhY2hlIGludmFsaWRhdGlvbiBmYWlsZWQ6ICR7KGVycm9yIGFzIEVycm9yKS5tZXNzYWdlfWAsXG4gICAgICAgIExvZ0NvbnRleHQuQ0FDSEUsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgZXJyb3IgYXMgRXJyb3IsXG4gICAgICApO1xuICAgICAgdGhpcy5lbWl0RXZlbnQoJ2ludmFsaWRhdGlvbl9mYWlsZWQnLCB7IGVycm9yLCBzdHJhdGVneSwgdGFyZ2V0cyB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW52YWxpZGF0ZWRLZXlzOiAwLFxuICAgICAgICBpbnZhbGlkYXRlZE5hbWVzcGFjZXM6IDAsXG4gICAgICAgIGludmFsaWRhdGVkVGFnczogMCxcbiAgICAgICAga2V5czogW10sXG4gICAgICAgIG5hbWVzcGFjZXM6IFtdLFxuICAgICAgICB0YWdzOiBbXSxcbiAgICAgICAgaW52YWxpZGF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgZXhlY3V0aW9uVGltZSxcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2UsXG4gICAgICAgIG1ldGFkYXRhOiBvcHRpb25zPy5tZXRhZGF0YSB8fCB7fSxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaW52YWxpZGF0ZUJ5UnVsZVxuICAgKiBAZGVzY3JpcHRpb24g5qC55o2u6KeE5YiZ5omn6KGM57yT5a2Y5aSx5pWIXG4gICAqIEBwYXJhbSBydWxlSWQg6KeE5YiZSURcbiAgICogQHBhcmFtIF9jb250ZXh0IOaJp+ihjOS4iuS4i+aWh1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxJbnZhbGlkYXRpb25SZXN1bHQ+fSDlpLHmlYjnu5PmnpxcbiAgICovXG4gIGFzeW5jIGludmFsaWRhdGVCeVJ1bGUoXG4gICAgcnVsZUlkOiBzdHJpbmcsXG4gICAgX2NvbnRleHQ/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgKTogUHJvbWlzZTxJbnZhbGlkYXRpb25SZXN1bHQ+IHtcbiAgICBjb25zdCBydWxlID0gdGhpcy5nZXRSdWxlKHJ1bGVJZCk7XG4gICAgaWYgKCFydWxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWRhdGlvbiBydWxlIG5vdCBmb3VuZDogJHtydWxlSWR9YCk7XG4gICAgfVxuXG4gICAgaWYgKCFydWxlLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oXG4gICAgICAgIGBJbnZhbGlkYXRpb24gcnVsZSBpcyBkaXNhYmxlZDogJHtydWxlLm5hbWV9YCxcbiAgICAgICAgTG9nQ29udGV4dC5DQUNIRSxcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnZhbGlkYXRlZEtleXM6IDAsXG4gICAgICAgIGludmFsaWRhdGVkTmFtZXNwYWNlczogMCxcbiAgICAgICAgaW52YWxpZGF0ZWRUYWdzOiAwLFxuICAgICAgICBrZXlzOiBbXSxcbiAgICAgICAgbmFtZXNwYWNlczogW10sXG4gICAgICAgIHRhZ3M6IFtdLFxuICAgICAgICBpbnZhbGlkYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICBleGVjdXRpb25UaW1lOiAwLFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdSdWxlIGlzIGRpc2FibGVkJyxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8g5qOA5p+l5p2h5Lu2XG4gICAgaWYgKHJ1bGUuY29uZGl0aW9uICYmICF0aGlzLmV2YWx1YXRlQ29uZGl0aW9uKHJ1bGUuY29uZGl0aW9uLCBfY29udGV4dCkpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICBgSW52YWxpZGF0aW9uIHJ1bGUgY29uZGl0aW9uIG5vdCBtZXQ6ICR7cnVsZS5uYW1lfWAsXG4gICAgICAgIExvZ0NvbnRleHQuQ0FDSEUsXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW52YWxpZGF0ZWRLZXlzOiAwLFxuICAgICAgICBpbnZhbGlkYXRlZE5hbWVzcGFjZXM6IDAsXG4gICAgICAgIGludmFsaWRhdGVkVGFnczogMCxcbiAgICAgICAga2V5czogW10sXG4gICAgICAgIG5hbWVzcGFjZXM6IFtdLFxuICAgICAgICB0YWdzOiBbXSxcbiAgICAgICAgaW52YWxpZGF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgZXhlY3V0aW9uVGltZTogMCxcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnQ29uZGl0aW9uIG5vdCBtZXQnLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyDmo4Dmn6Xkvp3otZZcbiAgICBpZiAocnVsZS5kZXBlbmRlbmNpZXMgJiYgcnVsZS5kZXBlbmRlbmNpZXMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBkZXBJZCBvZiBydWxlLmRlcGVuZGVuY2llcykge1xuICAgICAgICBjb25zdCBkZXBSdWxlID0gdGhpcy5nZXRSdWxlKGRlcElkKTtcbiAgICAgICAgaWYgKCFkZXBSdWxlPy5lbmFibGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgICAgICAgIGBEZXBlbmRlbmN5IHJ1bGUgbm90IGZvdW5kIG9yIGRpc2FibGVkOiAke2RlcElkfWAsXG4gICAgICAgICAgICBMb2dDb250ZXh0LkNBQ0hFLFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludmFsaWRhdGVkS2V5czogMCxcbiAgICAgICAgICAgIGludmFsaWRhdGVkTmFtZXNwYWNlczogMCxcbiAgICAgICAgICAgIGludmFsaWRhdGVkVGFnczogMCxcbiAgICAgICAgICAgIGtleXM6IFtdLFxuICAgICAgICAgICAgbmFtZXNwYWNlczogW10sXG4gICAgICAgICAgICB0YWdzOiBbXSxcbiAgICAgICAgICAgIGludmFsaWRhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICBleGVjdXRpb25UaW1lOiAwLFxuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ0RlcGVuZGVuY3kgbm90IHNhdGlzZmllZCcsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmludmFsaWRhdGUocnVsZS5wYXR0ZXJuLCBydWxlLnN0cmF0ZWd5LCB7XG4gICAgICBtZXRhZGF0YTogeyBydWxlSWQsIHJ1bGVOYW1lOiBydWxlLm5hbWUsIF9jb250ZXh0IH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBnZXRTdGF0c1xuICAgKiBAZGVzY3JpcHRpb24g6I635Y+W5aSx5pWI57uf6K6h5L+h5oGvXG4gICAqIEByZXR1cm5zIHtJbnZhbGlkYXRpb25TdGF0c30g57uf6K6h5L+h5oGvXG4gICAqL1xuICBnZXRTdGF0cygpOiBJbnZhbGlkYXRpb25TdGF0cyB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5zdGF0cyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcmVzZXRTdGF0c1xuICAgKiBAZGVzY3JpcHRpb24g6YeN572u5aSx5pWI57uf6K6h5L+h5oGvXG4gICAqL1xuICByZXNldFN0YXRzKCk6IHZvaWQge1xuICAgIHRoaXMuc3RhdHMgPSB0aGlzLmluaXRpYWxpemVTdGF0cygpO1xuICAgIHRoaXMubG9nZ2VyLmluZm8oJ0ludmFsaWRhdGlvbiBzdGF0cyByZXNldCcsIExvZ0NvbnRleHQuQ0FDSEUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgb25EZXN0cm95XG4gICAqIEBkZXNjcmlwdGlvbiDplIDmr4Hml7bmuIXnkIbotYTmupBcbiAgICovXG4gIG9uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnN0b3BNb25pdG9yaW5nKCk7XG4gICAgdGhpcy5sb2dnZXIuaW5mbygnQ2FjaGVJbnZhbGlkYXRpb25TZXJ2aWNlIGRlc3Ryb3llZCcsIExvZ0NvbnRleHQuQ0FDSEUpO1xuICB9XG5cbiAgLy8g56eB5pyJ5pa55rOVXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgaW5pdGlhbGl6ZVN0YXRzXG4gICAqIEBkZXNjcmlwdGlvbiDliJ3lp4vljJbnu5/orqHkv6Hmga9cbiAgICogQHJldHVybnMge0ludmFsaWRhdGlvblN0YXRzfSDliJ3lp4vnu5/orqHkv6Hmga9cbiAgICovXG4gIHByaXZhdGUgaW5pdGlhbGl6ZVN0YXRzKCk6IEludmFsaWRhdGlvblN0YXRzIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG90YWxJbnZhbGlkYXRpb25zOiAwLFxuICAgICAgc3VjY2Vzc2Z1bEludmFsaWRhdGlvbnM6IDAsXG4gICAgICBmYWlsZWRJbnZhbGlkYXRpb25zOiAwLFxuICAgICAgYXZlcmFnZUV4ZWN1dGlvblRpbWU6IDAsXG4gICAgICB0b3RhbEludmFsaWRhdGVkS2V5czogMCxcbiAgICAgIGFjdGl2ZVJ1bGVzOiAwLFxuICAgICAgbGFzdEludmFsaWRhdGlvbjogbmV3IERhdGUoKSxcbiAgICAgIHN0cmF0ZWd5VXNhZ2U6IE9iamVjdC52YWx1ZXMoSW52YWxpZGF0aW9uU3RyYXRlZ3kpLnJlZHVjZShcbiAgICAgICAgKGFjYywgc3RyYXRlZ3kpID0+IHtcbiAgICAgICAgICBhY2Nbc3RyYXRlZ3ldID0gMDtcbiAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LFxuICAgICAgICB7fSBhcyBSZWNvcmQ8SW52YWxpZGF0aW9uU3RyYXRlZ3ksIG51bWJlcj4sXG4gICAgICApLFxuICAgICAgdHJpZ2dlclVzYWdlOiBPYmplY3QudmFsdWVzKEludmFsaWRhdGlvblRyaWdnZXIpLnJlZHVjZShcbiAgICAgICAgKGFjYywgdHJpZ2dlcikgPT4ge1xuICAgICAgICAgIGFjY1t0cmlnZ2VyXSA9IDA7XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSxcbiAgICAgICAge30gYXMgUmVjb3JkPEludmFsaWRhdGlvblRyaWdnZXIsIG51bWJlcj4sXG4gICAgICApLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBpbnZhbGlkYXRlRXhhY3RcbiAgICogQGRlc2NyaXB0aW9uIOeyvuehruWMuemFjeWkseaViFxuICAgKiBAcGFyYW0ga2V5cyDnvJPlrZjplK7liJfooahcbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nW10+fSDlpLHmlYjnmoTplK7liJfooahcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW52YWxpZGF0ZUV4YWN0KGtleXM6IHN0cmluZ1tdKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGNvbnN0IGludmFsaWRhdGVkS2V5czogc3RyaW5nW10gPSBbXTtcblxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIOino+aekOWujOaVtOeahOmUruWtl+espuS4slxuICAgICAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMua2V5RmFjdG9yeS5wYXJzZShrZXkpO1xuICAgICAgICBjb25zdCBkZWxldGVkID0gYXdhaXQgdGhpcy5jYWNoZVNlcnZpY2UhLmRlbGV0ZShjYWNoZUtleSk7XG4gICAgICAgIGlmIChkZWxldGVkKSB7XG4gICAgICAgICAgaW52YWxpZGF0ZWRLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgICAgICBgRmFpbGVkIHRvIGludmFsaWRhdGUgZXhhY3Qga2V5OiAke2tleX1gLFxuICAgICAgICAgIExvZ0NvbnRleHQuQ0FDSEUsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIGVycm9yIGFzIEVycm9yLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbnZhbGlkYXRlZEtleXM7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBpbnZhbGlkYXRlUHJlZml4XG4gICAqIEBkZXNjcmlwdGlvbiDliY3nvIDljLnphY3lpLHmlYhcbiAgICogQHBhcmFtIHByZWZpeGVzIOWJjee8gOWIl+ihqFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmdbXT59IOWkseaViOeahOmUruWIl+ihqFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBpbnZhbGlkYXRlUHJlZml4KHByZWZpeGVzOiBzdHJpbmdbXSk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAvLyDov5nph4zpnIDopoHnvJPlrZjmnI3liqHmlK/mjIHliY3nvIDmn6Xor6LvvIznroDljJblrp7njrBcbiAgICBjb25zdCBpbnZhbGlkYXRlZEtleXM6IHN0cmluZ1tdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHByZWZpeCBvZiBwcmVmaXhlcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8g5YGH6K6+57yT5a2Y5pyN5Yqh5pSv5oyB5oyJ5ZG95ZCN56m66Ze05riF6ZmkXG4gICAgICAgIGNvbnN0IGNsZWFyZWQgPSBhd2FpdCB0aGlzLmNhY2hlU2VydmljZSEuY2xlYXIocHJlZml4KTtcbiAgICAgICAgaWYgKGNsZWFyZWQpIHtcbiAgICAgICAgICBpbnZhbGlkYXRlZEtleXMucHVzaChwcmVmaXgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFxuICAgICAgICAgIGBGYWlsZWQgdG8gaW52YWxpZGF0ZSBwcmVmaXg6ICR7cHJlZml4fWAsXG4gICAgICAgICAgTG9nQ29udGV4dC5DQUNIRSxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgZXJyb3IgYXMgRXJyb3IsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGludmFsaWRhdGVkS2V5cztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGludmFsaWRhdGVTdWZmaXhcbiAgICogQGRlc2NyaXB0aW9uIOWQjue8gOWMuemFjeWkseaViFxuICAgKiBAcGFyYW0gX3N1ZmZpeGVzIOWQjue8gOWIl+ihqFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmdbXT59IOWkseaViOeahOmUruWIl+ihqFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBpbnZhbGlkYXRlU3VmZml4KF9zdWZmaXhlczogc3RyaW5nW10pOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgLy8g566A5YyW5a6e546w77yM5a6e6ZmF6ZyA6KaB57yT5a2Y5pyN5Yqh5pSv5oyB5ZCO57yA5p+l6K+iXG4gICAgY29uc3QgaW52YWxpZGF0ZWRLZXlzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgLy8g6L+Z6YeM6ZyA6KaB6YGN5Y6G5omA5pyJ57yT5a2Y6ZSu5p2l5Yy56YWN5ZCO57yAXG4gICAgLy8g5a6e6ZmF5a6e546w5Lit5Y+v6IO96ZyA6KaB57yT5a2Y5pyN5Yqh5o+Q5L6b6ZSu5YiX6KGo5p+l6K+i5Yqf6IO9XG5cbiAgICByZXR1cm4gaW52YWxpZGF0ZWRLZXlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgaW52YWxpZGF0ZVdpbGRjYXJkXG4gICAqIEBkZXNjcmlwdGlvbiDpgJrphY3nrKbljLnphY3lpLHmlYhcbiAgICogQHBhcmFtIHBhdHRlcm5zIOmAmumFjeespuaooeW8j+WIl+ihqFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmdbXT59IOWkseaViOeahOmUruWIl+ihqFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBpbnZhbGlkYXRlV2lsZGNhcmQocGF0dGVybnM6IHN0cmluZ1tdKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGNvbnN0IGludmFsaWRhdGVkS2V5czogc3RyaW5nW10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBwYXR0ZXJucykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8g5LuF6K6w5b2V5qih5byP77yM5a6e6ZmF5Yy56YWN5L6d6LWW5YW35L2T57yT5a2Y5a6e546wXG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICAgIGBXaWxkY2FyZCBpbnZhbGlkYXRpb24gcGF0dGVybjogJHtwYXR0ZXJufWAsXG4gICAgICAgICAgTG9nQ29udGV4dC5DQUNIRSxcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXG4gICAgICAgICAgYEZhaWxlZCB0byBpbnZhbGlkYXRlIHdpbGRjYXJkIHBhdHRlcm46ICR7cGF0dGVybn1gLFxuICAgICAgICAgIExvZ0NvbnRleHQuQ0FDSEUsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIGVycm9yIGFzIEVycm9yLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbnZhbGlkYXRlZEtleXM7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBpbnZhbGlkYXRlUmVnZXhcbiAgICogQGRlc2NyaXB0aW9uIOato+WImeihqOi+vuW8j+WMuemFjeWkseaViFxuICAgKiBAcGFyYW0gcGF0dGVybnMg5q2j5YiZ6KGo6L6+5byP5qih5byP5YiX6KGoXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ1tdPn0g5aSx5pWI55qE6ZSu5YiX6KGoXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGludmFsaWRhdGVSZWdleChwYXR0ZXJuczogc3RyaW5nW10pOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgY29uc3QgaW52YWxpZGF0ZWRLZXlzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHBhdHRlcm5zKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyDku4XorrDlvZXmqKHlvI/vvIzlrp7pmYXljLnphY3kvp3otZblhbfkvZPnvJPlrZjlrp7njrBcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICAgICAgYFJlZ2V4IGludmFsaWRhdGlvbiBwYXR0ZXJuOiAke3BhdHRlcm59YCxcbiAgICAgICAgICBMb2dDb250ZXh0LkNBQ0hFLFxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgICAgICBgRmFpbGVkIHRvIGludmFsaWRhdGUgcmVnZXggcGF0dGVybjogJHtwYXR0ZXJufWAsXG4gICAgICAgICAgTG9nQ29udGV4dC5DQUNIRSxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgZXJyb3IgYXMgRXJyb3IsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGludmFsaWRhdGVkS2V5cztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGludmFsaWRhdGVUYWdzXG4gICAqIEBkZXNjcmlwdGlvbiDmoIfnrb7ljLnphY3lpLHmlYhcbiAgICogQHBhcmFtIHRhZ3Mg5qCH562+5YiX6KGoXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ1tdPn0g5aSx5pWI55qE5qCH562+5YiX6KGoXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGludmFsaWRhdGVUYWdzKHRhZ3M6IHN0cmluZ1tdKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIC8vIOeugOWMluWunueOsO+8jOWunumZhemcgOimgee8k+WtmOacjeWKoeaUr+aMgeagh+etvuafpeivolxuICAgIGNvbnN0IGludmFsaWRhdGVkVGFnczogc3RyaW5nW10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIOi/memHjOmcgOimgee8k+WtmOacjeWKoeaUr+aMgeagh+etvuWkseaViFxuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgVGFnIGludmFsaWRhdGlvbjogJHt0YWd9YCwgTG9nQ29udGV4dC5DQUNIRSk7XG4gICAgICAgIGludmFsaWRhdGVkVGFncy5wdXNoKHRhZyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFxuICAgICAgICAgIGBGYWlsZWQgdG8gaW52YWxpZGF0ZSB0YWc6ICR7dGFnfWAsXG4gICAgICAgICAgTG9nQ29udGV4dC5DQUNIRSxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgZXJyb3IgYXMgRXJyb3IsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGludmFsaWRhdGVkVGFncztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGludmFsaWRhdGVOYW1lc3BhY2VzXG4gICAqIEBkZXNjcmlwdGlvbiDlkb3lkI3nqbrpl7TljLnphY3lpLHmlYhcbiAgICogQHBhcmFtIG5hbWVzcGFjZXMg5ZG95ZCN56m66Ze05YiX6KGoXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ1tdPn0g5aSx5pWI55qE5ZG95ZCN56m66Ze05YiX6KGoXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGludmFsaWRhdGVOYW1lc3BhY2VzKG5hbWVzcGFjZXM6IHN0cmluZ1tdKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGNvbnN0IGludmFsaWRhdGVkTmFtZXNwYWNlczogc3RyaW5nW10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgbmFtZXNwYWNlIG9mIG5hbWVzcGFjZXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNsZWFyZWQgPSBhd2FpdCB0aGlzLmNhY2hlU2VydmljZSEuY2xlYXIobmFtZXNwYWNlKTtcbiAgICAgICAgaWYgKGNsZWFyZWQpIHtcbiAgICAgICAgICBpbnZhbGlkYXRlZE5hbWVzcGFjZXMucHVzaChuYW1lc3BhY2UpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFxuICAgICAgICAgIGBGYWlsZWQgdG8gaW52YWxpZGF0ZSBuYW1lc3BhY2U6ICR7bmFtZXNwYWNlfWAsXG4gICAgICAgICAgTG9nQ29udGV4dC5DQUNIRSxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgZXJyb3IgYXMgRXJyb3IsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGludmFsaWRhdGVkTmFtZXNwYWNlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGludmFsaWRhdGVCYXRjaFxuICAgKiBAZGVzY3JpcHRpb24g5om56YeP5aSx5pWIXG4gICAqIEBwYXJhbSB0YXJnZXRzIOebruagh+WIl+ihqFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmdbXT59IOWkseaViOeahOmUruWIl+ihqFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBpbnZhbGlkYXRlQmF0Y2godGFyZ2V0czogc3RyaW5nW10pOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgY29uc3QgaW52YWxpZGF0ZWRLZXlzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IGJhdGNoU2l6ZSA9IHRoaXMuY29uZmlnLmJhdGNoU2l6ZSB8fCAxMDA7XG5cbiAgICAvLyDliIbmibnlpITnkIZcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpICs9IGJhdGNoU2l6ZSkge1xuICAgICAgY29uc3QgYmF0Y2ggPSB0YXJnZXRzLnNsaWNlKGksIGkgKyBiYXRjaFNpemUpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBiYXRjaEtleXMgPSBhd2FpdCB0aGlzLmludmFsaWRhdGVFeGFjdChiYXRjaCk7XG4gICAgICAgIGludmFsaWRhdGVkS2V5cy5wdXNoKC4uLmJhdGNoS2V5cyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFxuICAgICAgICAgIGBGYWlsZWQgdG8gaW52YWxpZGF0ZSBiYXRjaCAke2kgLyBiYXRjaFNpemUgKyAxfWAsXG4gICAgICAgICAgTG9nQ29udGV4dC5DQUNIRSxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgZXJyb3IgYXMgRXJyb3IsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGludmFsaWRhdGVkS2V5cztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGV2YWx1YXRlQ29uZGl0aW9uXG4gICAqIEBkZXNjcmlwdGlvbiDor4TkvLDmnaHku7booajovr7lvI9cbiAgICogQHBhcmFtIGNvbmRpdGlvbiDmnaHku7booajovr7lvI9cbiAgICogQHBhcmFtIF9jb250ZXh0IOaJp+ihjOS4iuS4i+aWh1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0g5p2h5Lu25piv5ZCm5ruh6LazXG4gICAqL1xuICBwcml2YXRlIGV2YWx1YXRlQ29uZGl0aW9uKFxuICAgIGNvbmRpdGlvbjogc3RyaW5nLFxuICAgIF9jb250ZXh0PzogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gICk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICAvLyDnroDljJblrp7njrDvvIzlrp7pmYXlj6/ku6Xkvb/nlKjooajovr7lvI/lvJXmk45cbiAgICAgIC8vIOi/memHjOWPquaYr+ekuuS+i++8jOWunumZheWunueOsOmcgOimgeabtOWkjeadgueahOihqOi+vuW8j+ino+aekFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oXG4gICAgICAgIGBGYWlsZWQgdG8gZXZhbHVhdGUgY29uZGl0aW9uOiAke2NvbmRpdGlvbn1gLFxuICAgICAgICBMb2dDb250ZXh0LkNBQ0hFLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIGVycm9yIGFzIEVycm9yLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCB1cGRhdGVTdGF0c1xuICAgKiBAZGVzY3JpcHRpb24g5pu05paw57uf6K6h5L+h5oGvXG4gICAqIEBwYXJhbSBzdHJhdGVneSDlpLHmlYjnrZbnlaVcbiAgICogQHBhcmFtIGV4ZWN1dGlvblRpbWUg5omn6KGM5pe26Ze0XG4gICAqIEBwYXJhbSBpbnZhbGlkYXRlZEtleXMg5aSx5pWI6ZSu5pWwXG4gICAqIEBwYXJhbSBmYWlsZWQg5piv5ZCm5aSx6LSlXG4gICAqL1xuICBwcml2YXRlIHVwZGF0ZVN0YXRzKFxuICAgIHN0cmF0ZWd5OiBJbnZhbGlkYXRpb25TdHJhdGVneSxcbiAgICBleGVjdXRpb25UaW1lOiBudW1iZXIsXG4gICAgaW52YWxpZGF0ZWRLZXlzOiBudW1iZXIsXG4gICAgZmFpbGVkID0gZmFsc2UsXG4gICk6IHZvaWQge1xuICAgIHRoaXMuc3RhdHMudG90YWxJbnZhbGlkYXRpb25zKys7XG5cbiAgICBpZiAoZmFpbGVkKSB7XG4gICAgICB0aGlzLnN0YXRzLmZhaWxlZEludmFsaWRhdGlvbnMrKztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0cy5zdWNjZXNzZnVsSW52YWxpZGF0aW9ucysrO1xuICAgICAgdGhpcy5zdGF0cy50b3RhbEludmFsaWRhdGVkS2V5cyArPSBpbnZhbGlkYXRlZEtleXM7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0cy5hdmVyYWdlRXhlY3V0aW9uVGltZSA9XG4gICAgICAodGhpcy5zdGF0cy5hdmVyYWdlRXhlY3V0aW9uVGltZSAqICh0aGlzLnN0YXRzLnRvdGFsSW52YWxpZGF0aW9ucyAtIDEpICtcbiAgICAgICAgZXhlY3V0aW9uVGltZSkgL1xuICAgICAgdGhpcy5zdGF0cy50b3RhbEludmFsaWRhdGlvbnM7XG5cbiAgICB0aGlzLnN0YXRzLmxhc3RJbnZhbGlkYXRpb24gPSBuZXcgRGF0ZSgpO1xuICAgIHRoaXMuc3RhdHMuYWN0aXZlUnVsZXMgPSBBcnJheS5mcm9tKHRoaXMucnVsZXMudmFsdWVzKCkpLmZpbHRlcihcbiAgICAgIHJ1bGUgPT4gcnVsZS5lbmFibGVkLFxuICAgICkubGVuZ3RoO1xuXG4gICAgaWYgKHRoaXMuc3RhdHMuc3RyYXRlZ3lVc2FnZVtzdHJhdGVneV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zdGF0cy5zdHJhdGVneVVzYWdlW3N0cmF0ZWd5XSsrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIGVtaXRFdmVudFxuICAgKiBAZGVzY3JpcHRpb24g5Y+R6YCB5aSx5pWI5LqL5Lu2XG4gICAqIEBwYXJhbSB0eXBlIOS6i+S7tuexu+Wei1xuICAgKiBAcGFyYW0gX2RhdGEg5LqL5Lu25pWw5o2uXG4gICAqL1xuICBwcml2YXRlIGVtaXRFdmVudCh0eXBlOiBzdHJpbmcsIF9kYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHZvaWQge1xuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVFdmVudHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoYGNhY2hlLmludmFsaWRhdGlvbi4ke3R5cGV9YCwge1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZGF0YTogX2RhdGEsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgIHNlcnZpY2VJZDogJ2NhY2hlLWludmFsaWRhdGlvbicsXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgICAgICBgRmFpbGVkIHRvIGVtaXQgaW52YWxpZGF0aW9uIGV2ZW50OiAke3R5cGV9YCxcbiAgICAgICAgICBMb2dDb250ZXh0LkNBQ0hFLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBlcnJvciBhcyBFcnJvcixcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBzdGFydE1vbml0b3JpbmdcbiAgICogQGRlc2NyaXB0aW9uIOW8gOWni+ebkeaOp1xuICAgKi9cbiAgcHJpdmF0ZSBzdGFydE1vbml0b3JpbmcoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY29uZmlnLm1vbml0b3JpbmdJbnRlcnZhbCAmJiB0aGlzLmNvbmZpZy5tb25pdG9yaW5nSW50ZXJ2YWwgPiAwKSB7XG4gICAgICB0aGlzLm1vbml0b3JpbmdUaW1lciA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnBlcmZvcm1Nb25pdG9yaW5nKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZGF0aW9uIG1vbml0b3JpbmcgZmFpbGVkJyxcbiAgICAgICAgICAgIExvZ0NvbnRleHQuQ0FDSEUsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICBlcnJvciBhcyBFcnJvcixcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzLmNvbmZpZy5tb25pdG9yaW5nSW50ZXJ2YWwpO1xuXG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICBgU3RhcnRlZCBpbnZhbGlkYXRpb24gbW9uaXRvcmluZywgaW50ZXJ2YWw6ICR7dGhpcy5jb25maWcubW9uaXRvcmluZ0ludGVydmFsfW1zYCxcbiAgICAgICAgTG9nQ29udGV4dC5DQUNIRSxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2Qgc3RvcE1vbml0b3JpbmdcbiAgICogQGRlc2NyaXB0aW9uIOWBnOatouebkeaOp1xuICAgKi9cbiAgcHJpdmF0ZSBzdG9wTW9uaXRvcmluZygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5tb25pdG9yaW5nVGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5tb25pdG9yaW5nVGltZXIpO1xuICAgICAgdGhpcy5tb25pdG9yaW5nVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKCdTdG9wcGVkIGludmFsaWRhdGlvbiBtb25pdG9yaW5nJywgTG9nQ29udGV4dC5DQUNIRSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgcGVyZm9ybU1vbml0b3JpbmdcbiAgICogQGRlc2NyaXB0aW9uIOaJp+ihjOebkeaOp1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBwZXJmb3JtTW9uaXRvcmluZygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdHMgPSB0aGlzLmdldFN0YXRzKCk7XG4gICAgICB0aGlzLmVtaXRFdmVudCgnbW9uaXRvcmluZycsIHsgc3RhdHMgfSk7XG5cbiAgICAgIC8vIOajgOafpea0u+i3g+inhOWImVxuICAgICAgY29uc3QgYWN0aXZlUnVsZXMgPSBBcnJheS5mcm9tKHRoaXMucnVsZXMudmFsdWVzKCkpLmZpbHRlcihcbiAgICAgICAgcnVsZSA9PiBydWxlLmVuYWJsZWQsXG4gICAgICApO1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICAgIGBBY3RpdmUgaW52YWxpZGF0aW9uIHJ1bGVzOiAke2FjdGl2ZVJ1bGVzLmxlbmd0aH1gLFxuICAgICAgICBMb2dDb250ZXh0LkNBQ0hFLFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICdJbnZhbGlkYXRpb24gbW9uaXRvcmluZyBleGVjdXRpb24gZmFpbGVkJyxcbiAgICAgICAgTG9nQ29udGV4dC5DQUNIRSxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBlcnJvciBhcyBFcnJvcixcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG4iXSwidmVyc2lvbiI6M30=